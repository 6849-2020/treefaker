{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/assets/img/TreeFakerLogo.svg","webpack:///./src/App.vue?3aea","webpack:///./src/components/TreeFaker.vue?bbb6","webpack:///./src/components/TreeView.vue?31a8","webpack:///./src/engine/packing/index.ts","webpack:///./src/components/TreeView.vue","webpack:///./src/components/TreeView.vue?0fae","webpack:///./src/components/TreeView.vue?3e55","webpack:///./src/components/CreasesView.vue?388b","webpack:///./src/engine/creases/export.ts","webpack:///./src/engine/creases/index.ts","webpack:///./src/engine/creases/ordering.ts","webpack:///./tests/helper/index.ts","webpack:///./src/components/CreasesView.vue","webpack:///./src/components/CreasesView.vue?7bb1","webpack:///./src/components/CreasesView.vue?ab6c","webpack:///./src/components/PackingView.vue?5b5a","webpack:///./src/engine/packing/constraints.ts","webpack:///./src/engine/packing/alm.ts","webpack:///./src/components/PackingView.vue","webpack:///./src/components/PackingView.vue?f6c6","webpack:///./src/components/PackingView.vue?e8d0","webpack:///./src/components/TreeFaker.vue","webpack:///./src/components/TreeFaker.vue?aaf4","webpack:///./src/components/TreeFaker.vue?f6ea","webpack:///./src/App.vue","webpack:///./src/App.vue?0ab4","webpack:///./src/App.vue?bff9","webpack:///./src/main.ts"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","_vm","this","_h","$createElement","_c","_self","staticRenderFns","attrs","staticClass","exportDisabled","on","exportFold","_v","directives","rawName","modifiers","ref","generatePacking","expression","creasesDisabled","getCreasePattern","origamiSimulator","staticStyle","inErrorState","_s","errorMessage","TOLERANCE","UPDATE_TOLERANCE","BINARY_SEARCH_TOLERANCE","IS_RIGHT_TURN_CUTOFF_1","Math","PI","IS_RIGHT_TURN_CUTOFF_2","IS_RIGHT_TURN_CUTOFF_3","IS_RIGHT_TURN_CUTOFF_4","getAnyElement","e","Error","getIdString","id1","id2","CreaseType","MVAssignment","id","x","y","edges","index","indexOf","from","to","numEdges","console","log","scaleFactor","nodes","Map","displayId","elevation","faces","onBoundaryOfSquare","goUpRidge","hasPseudohinge","CreasesGraphState","creaseType","baseFace","leftFace","rightFace","Axial","assignment","Unknown","updateCreaseType","ActiveHull","InactiveHull","Boundary","Gusset","Pseudohinge","Valley","Ridge","Mountain","f","isOuterFace","inactiveHullCrease","crossRidge","crossGussetOrPseudohinge","crossAxialOrHull","extendedHasPseudohinge","flap","Set","corridor","creaseToNextAxialFacet","creaseToPreviousAxialFacet","facetOrderIndex","isColored","coloring","baseFaceLocalRoot","moleculeSource","total","adj","face","has","add","set","face1","face2","map","adjList","explored","forEach","topologicalSortHelper","encounteredFaces","adjacentFace","reverse","fromAngle","atan2","toAngle","otherEdge","otherNode","getOtherNode","otherEdgeAngle","angleDifference","abs","idString","v1","v2","fromIndex","toIndex","delete","getEdge","removeEdge","keys","fromNodeId","fromNode","distancesTo","getDistancesRecursive","distanceSoFar","distancesAlongPath","toNode","ePrime","Array","rootId","root","undefined","debugOverrideRootId","values","discreteDepth","dangleRecursive","depth","incidentEdge","nextNode","state","NewlyCreated","leafExtensions","nextInternalNodeIndex","nodeId","packingNode","creasesNode","addNode","toString","PreUMA","indexOfToNodeInLeftFace","indexOfFromNodeInRightFace","newNode","nextInternalId","firstCrease","addEdge","secondCrease","newCreases","e1","e3","v3","v2Angle","v3Angle","Hinge","newCrease","vStart","eStart","PostUMA","v","numIterations","foundBoundaryOfPolygon","inactiveHullEdge","clockwise","highestSumElevations","newSumElevations","sumElevations","otherFace","getOtherFace","theOuterFace","oldFaces","fillInFaceToTheLeft","eulerChar","size","axialNonPseudohingeFacets","annotateFaceData","numIterations1","corridorHasNotTerminated","numIterations2","nextFace","didDeleteEndpoint","faceOfCorridor","occurrences","axialCrease","internalNodes","pop","maxNumOccurrences","numOccurrences","readyToCreateNewPoint","pointIdsInUse","nextPointId","edgeLengthLabelOf","treePoints","adjustVerts","adjustPt","adjustAngle","treeBoard","undoPoints","currentUndoPoint","initBoard","boundingbox","showCopyright","initialPoint1","createPoint","initialPoint2","createLine","setUndoPoint","addEventListener","ctrlKey","deserialize","toCoords","cx","cy","newAngle","sin","cos","pt","moveTo","orig","offset","tree","newPoints","point","px","X","py","Y","seen","edge","p1","point1","p2","point2","p1x","p1y","p2x","p2y","sqrt","pow","suspendUpdate","removeObject","objectsList","resetState","nodeToPoint","node","parseInt","resetNextPointId","unsuspendUpdate","first","serialize","$store","commit","vertices","fromPoint","toPoint","incidentLine","otherPoint","findSubtree","newDistance","Number","prompt","smallerSubtree","oldDistance","Dist","xGap","yGap","dx","dy","subtree1","subtree2","setPosition","endPoint","setOfIncidentEdges","edgeLengthLabel","smallerSubtreeVertices","smallerSubtreeEdges","subtree1Vertices","subtree1Edges","subtree2Vertices","subtree2Edges","line","deleteLine","newLine","fixed","newLineEdgeLengthLabel","toFixed","highlight","shiftKey","deleteSubtree","which","changeEdgeLength","altKey","distsq1","distsq2","centerPoint","verts","forceName","label","newPoint","incidentLines","getCoordsTopLeftCorner","coords","usrCoords","component","edgeAssignmentShort","fanOutHinges","Unfolded","generateFold","graph","assignments","angles","faceVertices","vertexOrder","sort","edgeOrder","vertexEdges","vid","entries","idx","eid","toIdx","fromIdx","assn","nodeIds","reversedNodes","assign","faceNode","file_spec","file_creator","file_classes","vertices_coords","edges_vertices","edges_assignment","edges_foldAngle","vertices_edges","faces_vertices","activeDistance","distanceAlongPath","isActive","tolerance","xDistance","yDistance","distanceOnPlane","slack","get2CircleIntersection","x1","y1","r1","x2","y2","r2","onLeftSide","r1Squared","r2Squared","parallelX","parallelY","perpendicularX","perpendicularY","dSquared","twoDSquared","parallelDistanceScaled","perpendicularDistanceScaled","getIndexOfConvexGap","e2","v1Angle","cleanPacking","g","nodeQueue","updateNode","oldLeafExtension","u","Clean","numActivePaths","rOpt","possibleConstraintVertex","vectorFromActivePathX","vectorFromActivePathY","vectorFromActivePathLength","xOpt","yOpt","xDiff","yDiff","indexOfConvexGap","v1t","v2t","baseR1","baseR2","leftX","leftY","possibleConstraintVertices","neighboringEdge","dr","constraintViolated","isRightTurn","buildFaces","leastX","leastXVertex","points","v0","convexHull","stillComputingConvexHull","isRight","is180","removedPoint","foundOuterFace","undiscoveredEdges","edgeQueue","firstVertexOfConvexHull","secondVertexOfConvexHull","firstEdgeOfConvexHull","right","isTwisted","visitedEdgeStrings","faceIndex","vEnd","numInternalEdgesToCheck","pathIndex","edgeString","buildMoleculeRecursive","boundary","z","nn","rp","rn","mr","ip","iN","nip","nii","nin","dxp","dyp","magnitudeP","rpx","rpy","dxn","dyn","magnitudeN","rnx","rny","dxbis","dybis","magnitudeBis","bisx","bisy","innerProduct","rx","ry","h","rix","riy","rjx","rjy","riAngle","rjAngle","angleDiff","ni","nj","numeratorX","numeratorY","denominatorX","denominatorY","denominator","numerator","h1","lij","zMap","zDistances","ux","uy","vx","vy","w","a","b","lijp","newElevation","insetNodes","otherRidgeNodesArray","otherRidgeNodes","getOrMakeNode","nodeX","nodeY","checkInsetNodes","alreadyThereNode","boundaryNode","insetNodeX","insetNodeY","insetNode","madeNewNode","numberOfInsetNodes","finalRidgeCreaseNode1","finalRidgeCreaseNode2","chopOffFromJ","chopOffFromI","nodeJ","nodeI","temp1","temp2","insetNodeJ","insetNodeI","adjacentOnBoundary","nextIndex","previousIndex","distanceToI","distanceFromIToInsetJ","insetDistanceToI","insetZDistances","numInternalNodes","lastNode","k","internalNodeId","distanceToInternalNode","internalNode","insetDistanceToInternalNode","fractionOver","hingeNodeOnJRidge","hingeNodeOnInsetBoundary","distanceFromEnd","hingeNodeOnIRidge","ridgeCrease","nodesAlongRidge","concat","indexStack","newBoundaryStartIndex","newBoundaryEndIndex","newBoundary","activePathStartIndex","activePathEndIndex","activePathStartNode","activePathEndNode","temp","distanceFromStartToEnd","distanceDifference","subdivideCreasesInitial","nodeList","inactiveHullCreases","dMap","zDistanceMap","crease","distances","totalDistance","distanceToInternalNodeWithoutLeafExtension","newDepth","oldDepth","creaseFrom","creaseTo","subdivideCrease","generateMolecules","boundaries","outerFace","suppressNodeIfRedundant","orientation","endNode","currentNode","currentCrease","mag","ridgeline","baseCrease","creaseAttachedToRidgeVertex","lambda","rebuildFaces","PreFacetOrdering","getMVAssignment","f1","f2","computeMVAssignmentRecursive","correctAssignment","findNextNonPseudohingeFacet","isValidMOGMergePoint","axialFacet1","hinge1","nextAxialFacet1","axialFacet2","hinge2","hingeNodeId","baseFace2","assignUnfoldedHinges","globalSourceBaseFace","leftFlap","rightFlap","leftId","rightId","intersectingId","leftDepth","rightDepth","depthDifference","potentialMoleculeSource","localRoot","annotateExtendedPseudohinges","sourceFace","currentFace","possibleExtendedPseudohinges","foundPseudohinge","nextCrease","launchPseudohingeCorridors","orderingGraph","isOrdinaryDirection","addFace","nextFaceInCorridor","numVerticesInCorridor","lastCorridorFace","corridorFace","buildROGRecursive","visitedMolecules","mergePoint","globalSourceFace","positiveDirection","negativeDirection","jumpToOtherMolecule","orderFacets","initialBaseFace","initialFace","topologicalSort","FullyAssigned","decode","toReturn","leafExtension","possibleLeafExtension","getColor","useMV","creasesBoard","paramShowFacetOrder","paramShowMVAssignmentOnly","paramDisplayInternalNodes","packingCreasesSynced","treeGraph","creasesGraph","getDistances","findAGoodRoot","dangle","packing","err","message","vertexName","charAt","color","strokeColor","strokeWidth","averageX","averageY","fillColor","fold","blob","Blob","JSON","stringify","type","simulator","closed","open","source","status","postMessage","op","focus","MAX_SCALE","lbConstraint","lb","gradLbConstraint","deriv","ubConstraint","ub","gradUbConstraint","overlapConstraint","dists","scale","dist","scaledLength","gradOverlapConstraint","invDist","genConstraints","lbConstraints","fill","_","ubConstraints","overlapConstraints","genGradConstraints","gradLbConstraints","gradUbConstraints","gradOverlapConstraints","toMatrix","iKey","jKey","WEIGHT_START","WEIGHT_RATIO","WEIGHT_MAX","ITERS_OUTER","ITERS_INNER","ALF","EPS","EPSILON","X_TOL","G_TOL","maxStepSize","augLag","constraints","mult","weight","fn","lm","val","mu","gradAugLag","grad","gradMul","gradFn","gradVal","updateMultipliers","oldMult","newMult","outer","s1","s2","res","lineSearch","old","searchDirection","searchNorm","maxStep","slope","minStep","lastLm","lastF","lastX","XNew","fNew","fTarget","nextLm","rhs1","rhs2","lmSq","lastLmSq","lmDelta","discr","min","max","minimizeAugLag","last","lastStep","hessInv","iter","nextStep","xTest","gTest","gradDelta","hdg","fac","fae","sumDg","sumXi","facInv","fad","dg","hessInvDelta","solve","nConstraints","bestObjVal","bestSol","unscaledNextStep","feasibility","con","nextObjVal","packingBoard","showNavigation","clear","PERTURB_EPS","leafLengths","distanceMatrix","initSol","vKeys","Promise","resolve","twisted","finalErrorMessage","attempt","sol","trial","perturbedDists","perturbedConstraints","perturbedInitSol","cleanedPackingCreasesGraph","possibleErrorMessage","center","radius","use","generatingPacking","$refs","propagate","pack","creases","show","download","globalError","components","TreeView","CreasesView","PackingView","TreeFaker","config","productionTip","storeTemplate","mutations","updateTreeGraph","updateCreasesGraph","updatePacking","updateGlobalError","msg","clearGlobalError","unsync","sync","store","Store","render","$mount"],"mappings":"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","file":"js/app.f26b3fe2.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t\"app\": 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([0,\"chunk-vendors\"]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","module.exports = __webpack_public_path__ + \"img/TreeFakerLogo.4983e02e.svg\";","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('TreeFaker')}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('b-navbar',{attrs:{\"type\":\"dark\",\"variant\":\"dark\"}},[_c('b-navbar-nav',[_c('b-navbar-brand',{attrs:{\"href\":\"#\"}},[_c('img',{staticClass:\"logo\",attrs:{\"src\":require(\"../assets/img/TreeFakerLogo.svg\")}})]),_c('b-nav-item-dropdown',{attrs:{\"text\":\"File\",\"right\":\"\"}},[_c('b-dropdown-item',{attrs:{\"href\":\"#\",\"disabled\":_vm.exportDisabled},on:{\"click\":_vm.exportFold}},[_vm._v(\"Export to FOLD\")])],1),_c('b-nav-item',{directives:[{name:\"b-modal\",rawName:\"v-b-modal.controlsPopover\",modifiers:{\"controlsPopover\":true}}],attrs:{\"href\":\"#\"}},[_vm._v(\"Controls\")]),_c('b-nav-item',{directives:[{name:\"b-modal\",rawName:\"v-b-modal.aboutPopover\",modifiers:{\"aboutPopover\":true}}],attrs:{\"href\":\"#\"}},[_vm._v(\"About\")])],1)],1),_c('b-modal',{attrs:{\"id\":\"aboutPopover\",\"title\":\"About\",\"size\":\"lg\",\"ok-only\":\"\"}},[_c('p',{staticClass:\"description\"},[_vm._v(\"This tool was created by \"),_c('a',{attrs:{\"href\":\"https://pjrule.me/\",\"target\":\"_blank\"}},[_vm._v(\"Parker Rule\")]),_vm._v(\" and \"),_c('a',{attrs:{\"href\":\"http://www.jamie.tuckerfoltz.com/\",\"target\":\"_blank\"}},[_vm._v(\"Jamie Tucker-Foltz\")]),_vm._v(\" as a final project for \"),_c('a',{attrs:{\"href\":\"https://courses.csail.mit.edu/6.849/fall20/\",\"target\":\"_blank\"}},[_vm._v(\"6.849: Geometric Folding Algorithms\")]),_vm._v(\" (MIT), fall 2020.\")]),_c('p',{staticClass:\"description\"},[_vm._v(\"We are grateful for the guidance of Erik Demaine and Robert Lang, and we thank \"),_c('a',{attrs:{\"href\":\"https://tck.mn/\",\"target\":\"_blank\"}},[_vm._v(\"Andy Tockman\")]),_vm._v(\" for his contributions.\")])]),_c('b-modal',{attrs:{\"id\":\"controlsPopover\",\"title\":\"Controls\",\"size\":\"lg\",\"ok-only\":\"\"}},[_c('p',{staticClass:\"description\"},[_vm._v(\" Welcome to TreeFaker, an online, lightweight version of Robert Lang's \"),_c('a',{attrs:{\"href\":\"https://langorigami.com/article/treemaker/\",\"target\":\"_blank\"}},[_vm._v(\"TreeMaker\")]),_vm._v(\". To get started: \"),_c('ol',[_c('li',[_vm._v(\"Draw a tree in the left box. \"),_c('strong',[_vm._v(\"Ctrl + drag\")]),_vm._v(\" a vertex to add a new leaf to the tree. \"),_c('strong',[_vm._v(\"Alt + drag\")]),_vm._v(\" an edge to adjust the tree without changing edge lengths, or \"),_c('strong',[_vm._v(\"Alt + Ctrl + drag\")]),_vm._v(\" to fix the orientation of the subtree. \"),_c('strong',[_vm._v(\"Shift + click\")]),_vm._v(\" on an edge to delete it. \"),_c('strong',[_vm._v(\"Right click\")]),_vm._v(\" on an edge to manually set its length. Press \"),_c('strong',[_vm._v(\"Ctrl + Z\")]),_vm._v(\" or \"),_c('strong',[_vm._v(\"Ctrl + Y\")]),_vm._v(\" to undo or redo.\")]),_c('li',[_vm._v(\"When you are done drawing the tree, click \"),_c('strong',[_vm._v(\"Generate Disk Packing\")]),_vm._v(\".\")]),_c('li',[_vm._v(\"When you are satisfied with the disk packing, click \"),_c('strong',[_vm._v(\"Get Crease Pattern\")]),_vm._v(\".\")]),_c('li',[_vm._v(\"To export the crease pattern, click \"),_c('strong',[_vm._v(\"Open in Origami Simulator\")]),_vm._v(\" or \"),_c('strong',[_vm._v(\"File > Export FOLD\")]),_vm._v(\". \"),_c('em',[_vm._v(\"(As we have not fully implemented mountain/valley assignment, rendering in Origami Simulator may fail.)\")])])])])]),_c('div',{staticClass:\"container\"},[_c('table',{staticClass:\"views\"},[_c('tr',{staticClass:\"threeViews\"},[_c('td',{staticClass:\"viewBoxTd\"},[_c('TreeView',{ref:\"tree\"})],1),_c('td',{staticClass:\"spacer\"}),_c('td',{staticClass:\"viewBoxTd\"},[_c('PackingView',{ref:\"packing\"})],1),_c('td',{staticClass:\"spacer\"}),_c('td',{staticClass:\"viewBoxTd\"},[_c('CreasesView',{ref:\"creases\"})],1)]),_c('tr',{staticClass:\"threeButtons\"},[_c('td',[_c('b-button',{attrs:{\"variant\":\"primary\",\"size\":\"lg\"},on:{\"click\":_vm.generatePacking}},[_c('b-spinner',{directives:[{name:\"show\",rawName:\"v-show\",value:(_vm.generatingPacking),expression:\"generatingPacking\"}],attrs:{\"small\":\"\"}}),_vm._v(\" Generate Disk Packing \")],1)],1),_c('td'),_c('td',[_c('b-button',{attrs:{\"variant\":\"primary\",\"size\":\"lg\",\"disabled\":_vm.creasesDisabled},on:{\"click\":_vm.getCreasePattern}},[_vm._v(\" Get Crease Pattern \")])],1),_c('td'),_c('td',[_c('b-button',{attrs:{\"variant\":\"primary\",\"size\":\"lg\",\"disabled\":_vm.exportDisabled},on:{\"click\":_vm.origamiSimulator}},[_vm._v(\" Open in Origami Simulator \")])],1)])]),_c('input',{staticStyle:{\"display\":\"none\"},attrs:{\"type\":\"text\",\"id\":\"inputBox\"}}),_c('br'),_c('b-alert',{attrs:{\"show\":_vm.inErrorState,\"variant\":\"danger\"}},[_c('p',[_vm._v(_vm._s(_vm.errorMessage))])])],1)],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"viewBox\",attrs:{\"id\":\"treeViewBox\"}})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","import { matrix, math } from \"mathjs\";\n\nconst TOLERANCE = 0.000001;\nconst UPDATE_TOLERANCE = TOLERANCE * 5;\nconst BINARY_SEARCH_TOLERANCE = TOLERANCE / 1024;\nconst IS_RIGHT_TURN_CUTOFF_1 = -Math.PI - TOLERANCE;\nconst IS_RIGHT_TURN_CUTOFF_2 = Math.PI - TOLERANCE;\nconst IS_RIGHT_TURN_CUTOFF_3 = -2 * Math.PI + TOLERANCE;\nconst IS_RIGHT_TURN_CUTOFF_4 = 2 * Math.PI - TOLERANCE;\n\nfunction getAnyElement<T>(s: Set<T>) {\n  for (const e of s) {\n    return e;\n  }\n  throw new Error(\"Set is empty.\");\n}\n\nfunction getIdString(id1: string, id2: string) {\n  if (id1 > id2) {\n    return id2 + \"-\" + id1;\n  } else {\n    return id1 + \"-\" + id2;\n  }\n}\n\nclass Node {\n  readonly id: string;\n  x: number;\n  y: number;\n  edges: Edge[];\n  [key: string]: any;\n\n  constructor(id: string, x: number, y: number) {\n    this.id = id;\n    this.x = x;\n    this.y = y;\n    this.edges = [];\n  }\n\n  counterclockwise(e: Edge) {\n    const index = this.edges.indexOf(e);\n    if (index == -1) {\n      throw new Error(\n        `Edge ${e.from.id} -> ${e.to.id} not adjacent to vertex ${this.id}.`\n      );\n    } else {\n      const numEdges = this.edges.length;\n      return this.edges[(index + 1) % numEdges];\n    }\n  }\n\n  clockwise(e: Edge) {\n    const index = this.edges.indexOf(e);\n    if (index == -1) {\n      console.log(this);\n      throw new Error(\n        `Edge ${e.from.id} -> ${e.to.id} not adjacent to vertex ${this.id}.`\n      );\n    } else {\n      const numEdges = this.edges.length;\n      return this.edges[(index - 1 + numEdges) % numEdges];\n    }\n  }\n}\n\nclass Edge {\n  readonly to: Node;\n  readonly from: Node;\n  [key: string]: any;\n\n  constructor(to: Node, from: Node) {\n    this.to = to;\n    this.from = from;\n  }\n\n  getOtherNode(n: Node) {\n    if (n == this.to) {\n      return this.from;\n    } else if (n == this.from) {\n      return this.to;\n    } else {\n      throw new Error(\"Node not in edge.\");\n    }\n  }\n\n  idString() {\n    return getIdString(this.from.id, this.to.id);\n  }\n}\n\nclass TreeNode extends Node {}\n\nclass TreeEdge extends Edge {\n  readonly length: number;\n\n  constructor(to: TreeNode, from: TreeNode, length: number) {\n    super(to, from);\n    this.length = length;\n  }\n}\n\nclass PackingNode extends Node {}\n\nclass Packing {\n  scaleFactor: number;\n  nodes: Map<string, PackingNode>;\n\n  constructor() {\n    this.scaleFactor = 0;\n    this.nodes = new Map();\n  }\n}\n\nclass CreasesNode extends PackingNode {\n  displayId: string; // The id to be displayed in the GUI.\n  faces: Face[];\n  onBoundaryOfSquare: boolean;\n  goUpRidge: CreasesNode | null;\n  readonly elevation: number; // Not accurately set for vertices incident to 2 hinges and 2 ridges.\n  hasPseudohinge: boolean; // Whether the node sits at the top of a pseudohinge.\n\n  constructor(\n    id: string,\n    displayId: string,\n    x: number,\n    y: number,\n    elevation: number\n  ) {\n    super(id, x, y);\n    this.displayId = displayId;\n    this.faces = [];\n    this.onBoundaryOfSquare =\n      x < TOLERANCE || y < TOLERANCE || x > 1 - TOLERANCE || y > 1 - TOLERANCE;\n    this.goUpRidge = null;\n    this.elevation = elevation;\n    this.hasPseudohinge = false;\n  }\n}\n\nenum CreaseType {\n  Axial,\n  Gusset,\n  Ridge,\n  Hinge,\n  Pseudohinge,\n  ActiveHull,\n  InactiveHull\n}\n\nenum MVAssignment {\n  Mountain,\n  Valley,\n  Unfolded,\n  Unknown,\n  Boundary\n}\n\nclass Crease extends Edge {\n  readonly baseFace: Face | null; // The active polygon which this crease is inside of.\n  leftFace: Face | null;\n  rightFace: Face | null;\n  creaseType: CreaseType;\n  assignment: MVAssignment;\n\n  // Mapping from crease type to mountain/valley assignment.\n  updateCreaseType(creaseType: CreaseType) {\n    this.creaseType = creaseType;\n    if (\n      creaseType == CreaseType.ActiveHull ||\n      creaseType == CreaseType.InactiveHull\n    ) {\n      this.assignment = MVAssignment.Boundary;\n    } else if (\n      creaseType == CreaseType.Gusset ||\n      creaseType == CreaseType.Pseudohinge\n    ) {\n      this.assignment = MVAssignment.Valley;\n    } else if (creaseType == CreaseType.Ridge) {\n      this.assignment = MVAssignment.Mountain;\n    } else {\n      this.assignment = MVAssignment.Unknown;\n    }\n  }\n\n  getOtherFace(f: Face): Face {\n    if (f == this.leftFace) {\n      return this.rightFace as Face;\n    } else if (f == this.rightFace) {\n      return this.leftFace as Face;\n    } else {\n      throw new Error(\"Face not adjacent to edge.\");\n    }\n  }\n\n  sumElevations() {\n    return (\n      (this.from as CreasesNode).elevation + (this.to as CreasesNode).elevation\n    );\n  }\n\n  constructor(\n    to: CreasesNode,\n    from: CreasesNode,\n    creaseType: CreaseType,\n    baseFace: Face | null\n  ) {\n    super(to, from);\n    this.baseFace = baseFace;\n    this.leftFace = null;\n    this.rightFace = null;\n\n    // TODO These two lines are only necessary because TypeScript is being stupid.\n    this.creaseType = CreaseType.Axial;\n    this.assignment = MVAssignment.Unknown;\n\n    this.updateCreaseType(creaseType);\n  }\n}\n\nclass Face {\n  isOuterFace: boolean;\n  readonly nodes: CreasesNode[];\n  inactiveHullCrease: Crease | null;\n  crossRidge: Face | null; // The face on the other side of the highest elevation ridge.\n  crossGussetOrPseudohinge: Face | null; // May be null if on boundary of active polyton, indicating end of corridor.\n  crossAxialOrHull: Face | null; // Will be non-null if and only if the face is an axial facet.\n  hasPseudohinge: boolean;\n  extendedHasPseudohinge: boolean; // Whether there is a path crossing only unfolded creases to a pseudohinge facet.\n  flap: Set<string>; // Set of 2 tree node ids the face projects down to.\n  corridor: Face[] | null; // Will be non-null if and only if the face is an axial facet.\n  creaseToNextAxialFacet: Crease | null;\n  creaseToPreviousAxialFacet: Crease | null;\n  facetOrderIndex: number;\n  isColored: boolean;\n  coloring: boolean;\n  baseFaceLocalRoot: Face | string; // A pointer to the face representing the original active polygon or the local root id.\n  //isAMoleculeSource: boolean; // Whether the face is to the right of a local root hinge.\n  moleculeSource: Face | null; // The axial facet from which the MOG starts.\n  [key: string]: any;\n\n  averageX(): number {\n    let total = 0;\n    for (const n of this.nodes) {\n      total += n.x;\n    }\n    return total / this.nodes.length;\n  }\n\n  averageY(): number {\n    let total = 0;\n    for (const n of this.nodes) {\n      total += n.y;\n    }\n    return total / this.nodes.length;\n  }\n\n  constructor() {\n    this.isOuterFace = false;\n    this.nodes = [];\n    this.inactiveHullCrease = null;\n    this.crossRidge = null;\n    this.crossGussetOrPseudohinge = null;\n    this.crossAxialOrHull = null;\n    this.hasPseudohinge = false;\n    this.extendedHasPseudohinge = false;\n    this.flap = new Set();\n    this.corridor = null;\n    this.creaseToNextAxialFacet = null;\n    this.creaseToPreviousAxialFacet = null;\n    this.facetOrderIndex = -1;\n    this.isColored = false;\n    this.coloring = false;\n    this.baseFaceLocalRoot = \"unset\";\n    //this.isAMoleculeSource = false;\n    this.moleculeSource = null;\n  }\n}\n\nclass FacetOrderingGraph {\n  readonly faces: Set<Face>;\n  readonly adj: Map<Face, Face[]>;\n\n  constructor() {\n    this.faces = new Set();\n    this.adj = new Map();\n  }\n\n  addFace(face: Face) {\n    if (!this.faces.has(face)) {\n      this.faces.add(face);\n      this.adj.set(face, []);\n    }\n  }\n\n  addEdge(face1: Face, face2: Face) {\n    if (!this.faces.has(face1)) {\n      throw new Error(\n        `First face ${face1.nodes.map(n => n.id)} not in FacetOrderingGraph.`\n      );\n    }\n    if (!this.faces.has(face2)) {\n      throw new Error(\n        `Second face ${face2.nodes.map(n => n.id)} not in FacetOrderingGraph.`\n      );\n    }\n    const adjList = this.adj.get(face1) as Face[];\n    adjList.push(face2);\n  }\n\n  // Using topological sort algorithm cut-and-pasted from:\n  // https://www.tutorialspoint.com/Topological-sorting-using-Javascript-DFS\n  topologicalSortHelper(face: Face, explored: Set<Face>, s: Face[]) {\n    explored.add(face);\n\n    // Marks this node as visited and goes on to the nodes\n    // that are dependent on this node, the edge is node ----> n\n    const adjList = this.adj.get(face) as Face[];\n    adjList.forEach(f => {\n      if (!explored.has(f)) {\n        this.topologicalSortHelper(f, explored, s);\n      }\n    });\n    // All dependencies are resolved for this node, we can now add\n    // This to the stack.\n    s.push(face);\n  }\n\n  topologicalSort(): Face[] {\n    // Create a Stack to keep track of all elements in sorted order\n    const s: Face[] = [];\n    const explored: Set<Face> = new Set();\n\n    // For every unvisited node in our graph, call the helper.\n    this.faces.forEach(face => {\n      if (!explored.has(face)) {\n        this.topologicalSortHelper(face, explored, s);\n      }\n    });\n\n    // Verify all edges go the proper direction.\n    const encounteredFaces: Set<Face> = new Set();\n    for (const face of s) {\n      for (const adjacentFace of this.adj.get(face) as Face[]) {\n        if (!encounteredFaces.has(adjacentFace)) {\n          throw new Error(\n            `Facet ordering graph is not a DAG: cycle involving faces ${face.nodes.map(\n              n => n.id\n            )} and ${adjacentFace.nodes.map(n => n.id)}.`\n          );\n        }\n      }\n      encounteredFaces.add(face);\n    }\n\n    return s.reverse();\n  }\n}\n\nclass Graph<N extends Node, E extends Edge> {\n  nodes: Map<string, N>;\n  edges: Map<string, E>;\n\n  constructor() {\n    this.nodes = new Map();\n    this.edges = new Map();\n  }\n\n  addNode(n: N) {\n    if (this.nodes.has(n.id)) {\n      throw new Error(`Node with ID ${n.id} already exists.`);\n    } else {\n      this.nodes.set(n.id, n);\n    }\n  }\n\n  // Inserts edge at correct position within rotation system.\n  addEdge(e: E) {\n    if (!this.nodes.has(e.from.id)) {\n      throw new Error(`Cannot add an edge from nonexistent node ${e.from.id}.`);\n    }\n    if (!this.nodes.has(e.to.id)) {\n      throw new Error(`Cannot add an edge to nonexistent node ${e.to.id}.`);\n    }\n    const fromAngle = Math.atan2(e.to.y - e.from.y, e.to.x - e.from.x);\n    const toAngle = Math.atan2(e.from.y - e.to.y, e.from.x - e.to.x);\n    let i = e.from.edges.length - 1;\n    for (; i >= 0; i--) {\n      const otherEdge = e.from.edges[i];\n      const otherNode = otherEdge.getOtherNode(e.from);\n      const otherEdgeAngle = Math.atan2(\n        otherNode.y - e.from.y,\n        otherNode.x - e.from.x\n      );\n      const angleDifference = fromAngle - otherEdgeAngle;\n      if (Math.abs(angleDifference) < TOLERANCE) {\n        console.log(e);\n        throw new Error(\n          `Tried to add edge ${e.idString()} parallel to existing incident edge.`\n        );\n      } else if (angleDifference > 0) {\n        break;\n      }\n      e.from.edges[i + 1] = otherEdge;\n    }\n    e.from.edges[i + 1] = e;\n    i = e.to.edges.length - 1;\n    for (; i >= 0; i--) {\n      const otherEdge = e.to.edges[i];\n      const otherNode = otherEdge.getOtherNode(e.to);\n      const otherEdgeAngle = Math.atan2(\n        otherNode.y - e.to.y,\n        otherNode.x - e.to.x\n      );\n      const angleDifference = toAngle - otherEdgeAngle;\n      if (Math.abs(angleDifference) < TOLERANCE) {\n        console.log(e);\n        throw new Error(\n          `Tried to add edge parallel to existing incident edge.`\n        );\n      } else if (angleDifference > 0) {\n        break;\n      }\n      e.to.edges[i + 1] = otherEdge;\n    }\n    e.to.edges[i + 1] = e;\n    this.edges.set(e.idString(), e);\n  }\n\n  // Returns the edge between v1 and v2, or undefined if there is no such edge.\n  getEdge(v1: N, v2: N) {\n    const idString = getIdString(v1.id, v2.id);\n    return this.edges.get(idString);\n  }\n\n  removeEdge(e: E) {\n    const fromIndex = e.from.edges.indexOf(e);\n    const toIndex = e.to.edges.indexOf(e);\n    if (fromIndex == -1 || toIndex == -1 || !this.edges.delete(e.idString())) {\n      throw new Error(\n        `Edge ${e.from.id} -> ${e.to.id} not in graph or not in node edge list.`\n      );\n    } else {\n      e.from.edges.splice(fromIndex, 1);\n      e.to.edges.splice(toIndex, 1);\n    }\n  }\n\n  removeEdgeFromVertices(v1: N, v2: N) {\n    const e = this.getEdge(v1, v2);\n    if (e) {\n      this.removeEdge(e);\n    } else {\n      throw new Error(`Edge (${v1.id}, ${v2.id}) not in graph.`);\n    }\n  }\n}\n\nclass TreeGraph extends Graph<TreeNode, TreeEdge> {\n  debugOverrideRootId: string | undefined;\n\n  // Returns d such that, for all leaf nodes a and b, d.get(a).get(b) is a sorted list of ids and distances along the path from a to b.\n  getDistances(): Map<string, Map<string, Array<[string, number]>>> {\n    const d = new Map();\n    for (const fromNodeId of this.nodes.keys()) {\n      const fromNode = this.nodes.get(fromNodeId) as TreeNode;\n      if (fromNode.edges.length == 1) {\n        const distancesTo = new Map();\n        this.getDistancesRecursive(\n          distancesTo,\n          0,\n          [],\n          fromNode,\n          fromNode.edges[0] as TreeEdge\n        );\n        d.set(fromNodeId, distancesTo);\n      }\n    }\n    return d;\n  }\n\n  // Helper function for getDistances.\n  getDistancesRecursive(\n    distancesTo: Map<string, Array<[string, number]>>,\n    distanceSoFar: number,\n    distancesAlongPath: Array<[string, number]>,\n    fromNode: TreeNode,\n    e: TreeEdge\n  ) {\n    distanceSoFar += e.length;\n    const toNode = e.getOtherNode(fromNode);\n    distancesAlongPath.push([toNode.id, distanceSoFar]);\n    if (toNode.edges.length == 1) {\n      distancesTo.set(toNode.id, distancesAlongPath);\n    } else {\n      for (const ePrime of toNode.edges) {\n        if (ePrime.getOtherNode(toNode) != fromNode) {\n          this.getDistancesRecursive(\n            distancesTo,\n            distanceSoFar,\n            Array.from(distancesAlongPath),\n            toNode,\n            ePrime as TreeEdge\n          );\n        }\n      }\n    }\n  }\n\n  // Compute discrete depths from a given root.\n  // If rootId is unset, choose the highest y-coordinate branch node as the root.\n  dangle(rootId: string) {\n    let root: TreeNode | null = null;\n    if (this.debugOverrideRootId != undefined) {\n      root = this.nodes.get(this.debugOverrideRootId) as TreeNode;\n    } else if (rootId == \"unset\") {\n      for (const n of this.nodes.values()) {\n        if (n.edges.length >= 2 && (root == null || root.y < n.y)) {\n          root = n;\n        }\n      }\n    } else {\n      root = this.nodes.get(rootId) as TreeNode;\n    }\n    if (root == null) {\n      throw new Error(\"Tree has no non-leaf nodes.\");\n    } else {\n      const discreteDepth: Map<string, number> = new Map();\n      discreteDepth.set(\"unset\", 1000);\n      this.dangleRecursive(discreteDepth, root, 0);\n      return discreteDepth;\n    }\n  }\n\n  dangleRecursive(\n    discreteDepth: Map<string, number>,\n    n: TreeNode,\n    depth: number\n  ) {\n    if (!discreteDepth.has(n.id)) {\n      discreteDepth.set(n.id, depth);\n      for (const incidentEdge of n.edges) {\n        const nextNode = incidentEdge.getOtherNode(n);\n        this.dangleRecursive(discreteDepth, nextNode, depth + 1);\n      }\n    }\n  }\n}\n\n// The creases graph is modified in-place by several functions; these states are used to enforce that you don't try to make these calls in the wrong order.\nenum CreasesGraphState {\n  NewlyCreated,\n  Clean,\n  PreUMA,\n  PostUMA,\n  PreFacetOrdering,\n  FullyAssigned\n}\n\nclass CreasesGraph extends Graph<CreasesNode, Crease> {\n  state: CreasesGraphState;\n  leafExtensions: Map<CreasesNode, number>;\n  faces: Set<Face>;\n  nextInternalNodeIndex: number;\n\n  constructor(p: Packing) {\n    super();\n    this.state = CreasesGraphState.NewlyCreated;\n    this.leafExtensions = new Map();\n    this.faces = new Set();\n    this.nextInternalNodeIndex = 1;\n    for (const nodeId of p.nodes.keys()) {\n      const packingNode = p.nodes.get(nodeId) as PackingNode;\n      const creasesNode = new CreasesNode(\n        nodeId,\n        nodeId,\n        packingNode.x,\n        packingNode.y,\n        0\n      );\n      this.addNode(creasesNode);\n      this.leafExtensions.set(creasesNode, 0);\n    }\n  }\n\n  // For constructing new nodes that were not in the original packing.\n  nextInternalId() {\n    return \"i\" + (this.nextInternalNodeIndex++).toString();\n  }\n\n  // Splits a crease into two pieces, returning the node inserted in the middle. Does not check that x and y are actually coordinates of a point in the middle of the crease e.\n  subdivideCrease(\n    e: Crease,\n    x: number,\n    y: number,\n    displayId: string,\n    elevation: number\n  ) {\n    if (this.state != CreasesGraphState.PreUMA) {\n      throw new Error(`Do not call subdivideCrease from state ${this.state}.`);\n    }\n    const fromNode = e.from as CreasesNode;\n    const toNode = e.to as CreasesNode;\n    const leftFace = e.leftFace as Face;\n    const rightFace = e.rightFace as Face;\n    const indexOfToNodeInLeftFace = leftFace.nodes.indexOf(toNode);\n    const indexOfFromNodeInRightFace = rightFace.nodes.indexOf(fromNode);\n    const creaseType = e.creaseType;\n    const baseFace = e.baseFace;\n\n    this.removeEdge(e);\n    const newNode = new CreasesNode(\n      this.nextInternalId(),\n      displayId,\n      x,\n      y,\n      elevation\n    );\n    this.addNode(newNode);\n    const firstCrease = new Crease(newNode, fromNode, creaseType, baseFace);\n    this.addEdge(firstCrease);\n    firstCrease.leftFace = leftFace;\n    firstCrease.rightFace = rightFace;\n    const secondCrease = new Crease(toNode, newNode, creaseType, baseFace);\n    this.addEdge(secondCrease);\n    secondCrease.leftFace = leftFace;\n    secondCrease.rightFace = rightFace;\n    if (leftFace != rightFace) {\n      // Faces are only the same when input tree is a path,\n      // in which case we don't care about updating these pointers.\n      leftFace.nodes.splice(indexOfToNodeInLeftFace, 0, newNode);\n      rightFace.nodes.splice(indexOfFromNodeInRightFace, 0, newNode);\n    }\n    if (this.getEdge(newNode, fromNode) == undefined) {\n      console.log(this.edges);\n      throw new Error(\n        \"Problem subdividing crease - cannot find one of the new edges.\"\n      );\n    }\n    return newNode;\n  }\n\n  // Removes nodes that were created as part of the UMA insetting process, but are unnecessary for the final crease pattern since they have degree 2.\n  suppressNodeIfRedundant(v2: CreasesNode, newCreases: Set<Crease>) {\n    if (this.state != CreasesGraphState.PreUMA) {\n      throw new Error(\n        `Do not call suppressRidgeNodeIfRedundant from state ${\n          CreasesGraphState[this.state]\n        }.`\n      );\n    }\n    if (v2.edges.length == 2) {\n      const e1 = v2.edges[0] as Crease;\n      const e3 = v2.edges[1] as Crease;\n      const v1 = e1.getOtherNode(v2) as CreasesNode;\n      const v3 = e3.getOtherNode(v2) as CreasesNode;\n      const v2Angle = Math.atan2(v2.y - v1.y, v2.x - v1.x);\n      const v3Angle = Math.atan2(v3.y - v1.y, v3.x - v1.x);\n      const creaseType = e1.creaseType;\n      const baseFace = e1.baseFace;\n      if (Math.abs(v2Angle - v3Angle) < TOLERANCE) {\n        if (\n          creaseType != e3.creaseType ||\n          (creaseType != CreaseType.Ridge && creaseType != CreaseType.Hinge)\n        ) {\n          throw new Error(\n            `Invalid crease types: edge ${e1.idString()} is of type ${\n              e1.creaseType\n            } and edge ${e3.idString()} is of type ${e3.creaseType}.`\n          );\n        }\n        newCreases.delete(e1);\n        newCreases.delete(e3);\n        this.removeEdge(e1);\n        this.removeEdge(e3);\n        this.nodes.delete(v2.id);\n        const newCrease =\n          v1.elevation < v3.elevation\n            ? new Crease(v3, v1, creaseType, baseFace)\n            : new Crease(v1, v3, creaseType, baseFace);\n        newCreases.add(newCrease);\n        this.addEdge(newCrease);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Constructs a new face to the left of a crease by traversing the rotation system.\n  fillInFaceToTheLeft(vStart: CreasesNode, eStart: Crease) {\n    if (this.state != CreasesGraphState.PostUMA) {\n      throw new Error(\n        `Do not call fillInFaceToTheLeft from state ${\n          CreasesGraphState[this.state]\n        }.`\n      );\n    }\n    const face = new Face();\n    this.faces.add(face);\n    face.baseFaceLocalRoot = eStart.baseFace as Face;\n    let v = vStart;\n    let e = eStart;\n    for (let numIterations = 0; numIterations < 100; numIterations++) {\n      face.nodes.push(v);\n      if (v == e.from) {\n        e.leftFace = face;\n      } else {\n        e.rightFace = face;\n      }\n      const foundBoundaryOfPolygon =\n        e.creaseType == CreaseType.Axial ||\n        e.creaseType == CreaseType.ActiveHull ||\n        e.creaseType == CreaseType.InactiveHull;\n      if (e.creaseType == CreaseType.Pseudohinge) {\n        face.hasPseudohinge = true;\n      } else if (e.creaseType == CreaseType.InactiveHull) {\n        if (!face.isOuterFace) {\n          if (face.inactiveHullEdge == null) {\n            face.inactiveHullEdge = e;\n          } else {\n            throw new Error(\n              `Face ${face.nodes.map(\n                n => n.id\n              )} has at least two inactive hull edges: ${face.inactiveHullEdge.idString()} and ${e.idString()}.`\n            );\n          }\n        }\n      }\n      v = e.getOtherNode(v) as CreasesNode;\n      e = v.clockwise(e) as Crease;\n      if (foundBoundaryOfPolygon) {\n        face.creaseToNextAxialFacet = e;\n      }\n      if (v == vStart && e == eStart) {\n        return face;\n      }\n    }\n    throw new Error(\n      \"Caught in infinite loop while filling in new face in UMA.\"\n    );\n  }\n\n  // Sets crossRidge, crossGussetOrPseudohinge, crossHinge, and flap fields, returning set of axial facets.\n  annotateFaceData(face: Face) {\n    if (this.state != CreasesGraphState.PostUMA) {\n      throw new Error(\n        `Do not call annotateFaceData from state ${\n          CreasesGraphState[this.state]\n        }.`\n      );\n    }\n    let highestSumElevations = 0;\n    let v1 = face.nodes[face.nodes.length - 1];\n    for (const v2 of face.nodes) {\n      if (v2.displayId != \"\") {\n        face.flap.add(v2.displayId);\n      }\n      const e = this.getEdge(v1, v2) as Crease;\n      if (e.creaseType == CreaseType.Ridge) {\n        const newSumElevations = e.sumElevations();\n        const otherFace = e.getOtherFace(face) as Face;\n        if (otherFace.hasPseudohinge && (v1.hasPseudohinge || v2.hasPseudohinge)) {\n          // Ensure otherFace is crossRidge face.\n          highestSumElevations = 2;\n          face.crossRidge = otherFace;\n        } else if (newSumElevations > highestSumElevations) {\n          highestSumElevations = newSumElevations;\n          face.crossRidge = otherFace;\n        }\n      } else if (\n        e.creaseType == CreaseType.Gusset ||\n        e.creaseType == CreaseType.Pseudohinge\n      ) {\n        if (face.crossGussetOrPseudohinge == null) {\n          face.crossGussetOrPseudohinge = e.getOtherFace(face);\n        } else {\n          console.log(e);\n          throw new Error(\n            `Found two gusset/pseudohinge creases on one face, second is ${e.idString()}, which has type ${\n              CreaseType[e.creaseType]\n            }.`\n          );\n        }\n      } else if (e.creaseType == CreaseType.Hinge) {\n        //face.crossHinge = e.getOtherFace(face);\n      } else {\n        if (face.crossAxialOrHull == null) {\n          face.crossAxialOrHull = e.getOtherFace(face);\n          face.corridor = [face];\n        } else {\n          console.log(e);\n          throw new Error(\n            `Found two axial/hull creases on one face, second is ${e.idString()}, which has type ${\n              CreaseType[e.creaseType]\n            }.`\n          );\n        }\n      }\n      v1 = v2;\n    }\n    return face.crossAxialOrHull != null;\n  }\n\n  // Makes new faces to either side of every crease in newCreases, leaving theOuterFace untouched, then annotates faces with data necessary for facet ordering.\n  rebuildFaces(theOuterFace: Face, newCreases: Set<Crease>) {\n    if (this.state != CreasesGraphState.PostUMA) {\n      throw new Error(\n        `Do not call rebuildFaces from state ${CreasesGraphState[this.state]}.`\n      );\n    }\n\n    // Fill in all faces except theOuterFace.\n    const oldFaces = this.faces;\n    oldFaces.delete(theOuterFace);\n    this.faces = new Set([theOuterFace]);\n    for (const e of newCreases) {\n      if (e.leftFace == null || oldFaces.has(e.leftFace)) {\n        this.fillInFaceToTheLeft(e.from as CreasesNode, e);\n      }\n      if (e.rightFace == null || oldFaces.has(e.rightFace)) {\n        this.fillInFaceToTheLeft(e.to as CreasesNode, e);\n      }\n    }\n    const eulerChar = this.nodes.size - this.edges.size + this.faces.size;\n    if (eulerChar != 2) {\n      throw new Error(\n        `Euler characteristic check failed after building faces: v=${this.nodes.size}, e=${this.edges.size}, f=${this.faces.size}`\n      );\n    }\n\n    // Set all face pointers and get list of axial facets.\n    const axialNonPseudohingeFacets: Set<Face> = new Set();\n    for (const face of this.faces) {\n      if (face != theOuterFace) {\n        if (this.annotateFaceData(face) && !face.hasPseudohinge) {\n          axialNonPseudohingeFacets.add(face);\n        }\n      }\n    }\n\n    // Build corridors from each axial facet and set flaps as union.\n    for (let numIterations1 = 0; numIterations1 < 500; numIterations1++) {\n      if (axialNonPseudohingeFacets.size == 0) {\n        return;\n      } else {\n        let face = getAnyElement(axialNonPseudohingeFacets);\n        axialNonPseudohingeFacets.delete(face);\n        let corridorHasNotTerminated = true;\n        const corridor = face.corridor as Face[];\n        const flap: Set<string> = new Set(face.flap);\n        for (let numIterations2 = 0; numIterations2 < 100; numIterations2++) {\n          const nextFace =\n            numIterations2 % 2 == 0\n              ? face.crossRidge\n              : face.crossGussetOrPseudohinge;\n          if (nextFace == null) {\n            // Done building corridor.\n            const didDeleteEndpoint = axialNonPseudohingeFacets.delete(face);\n            if (!didDeleteEndpoint) {\n              console.log(corridor);\n              throw new Error(\n                `Corridor ${corridor.map(\n                  f => \"[\" + f.nodes.map(n => n.id) + \"]\"\n                )} ended somewhere that wasn't in list of axial facets.`\n              );\n            }\n            face.corridor = Array.from(corridor).reverse();\n\n            // Reset flaps with all ids encountered in corridor.\n            //console.log(`Setting flap of corridor [${corridor.map(f => \" \" + f.nodes.map(n => n.id).toString() + \" \")}] to ${Array.from(flap)}.`);\n            if (flap.size != 2) {\n              console.log(face);\n              throw new Error(`Could not determine flap: ${Array.from(flap)}.`);\n            }\n            for (const faceOfCorridor of corridor) {\n              faceOfCorridor.flap = flap;\n            }\n            corridorHasNotTerminated = false;\n            break;\n          } else {\n            corridor.push(nextFace);\n            for (const nodeId of nextFace.flap) {\n              flap.add(nodeId);\n            }\n            face = nextFace;\n          }\n        }\n        if (corridorHasNotTerminated) {\n          throw new Error(\n            \"Caught in infinite loop while building corridors (2).\"\n          );\n        }\n      }\n    }\n    throw new Error(\"Caught in infinite loop while building corridors (1).\");\n  }\n\n  // Returns the id of a branch node that hopefully wont cause MOG merge problems.\n  // If there are no axial paths, returns \"unset\".\n  findAGoodRoot(d: Map<string, Map<string, Array<[string, number]>>>): string {\n    const occurrences: Map<string, number> = new Map();\n    for (const axialCrease of this.edges.values()) {\n      if (axialCrease.creaseType == CreaseType.Axial) {\n        const internalNodes = Array.from(\n          (d.get(axialCrease.from.id) as Map<\n            string,\n            Array<[string, number]>\n          >).get(axialCrease.to.id) as Array<[string, number]>\n        );\n        internalNodes.pop();\n        for (const [nodeId, distance] of internalNodes) {\n          if (occurrences.has(nodeId)) {\n            occurrences.set(nodeId, (occurrences.get(nodeId) as number) + 1);\n          } else {\n            occurrences.set(nodeId, 1);\n          }\n        }\n      }\n    }\n\n    let rootId = \"unset\";\n    let maxNumOccurrences = 0;\n    for (const [nodeId, numOccurrences] of occurrences) {\n      if (numOccurrences > maxNumOccurrences) {\n        maxNumOccurrences = numOccurrences;\n        rootId = nodeId;\n      }\n    }\n    return rootId;\n  }\n}\n\nexport {\n  TOLERANCE,\n  UPDATE_TOLERANCE,\n  BINARY_SEARCH_TOLERANCE,\n  IS_RIGHT_TURN_CUTOFF_1,\n  IS_RIGHT_TURN_CUTOFF_2,\n  IS_RIGHT_TURN_CUTOFF_3,\n  IS_RIGHT_TURN_CUTOFF_4,\n  getAnyElement,\n  getIdString,\n  Node,\n  Edge,\n  Face,\n  TreeNode,\n  TreeEdge,\n  PackingNode,\n  Packing,\n  CreasesNode,\n  CreaseType,\n  MVAssignment,\n  Crease,\n  FacetOrderingGraph,\n  Graph,\n  TreeGraph,\n  CreasesGraphState,\n  CreasesGraph\n};\n","\n\n\n\n\nimport { Component, Prop, Vue } from \"vue-property-decorator\";\nimport {\n  JSXGraph,\n  Board,\n  Coords,\n  COORDS_BY_USER,\n  COORDS_BY_SCREEN,\n  getPosition\n} from \"jsxgraph\";\nimport { TreeGraph, TreeNode, TreeEdge } from \"../engine/packing\";\n\n@Component\nexport default class TreeView extends Vue {\n  readyToCreateNewPoint: boolean;\n  pointIdsInUse: Set<number>; // A set of all labels currently in use.\n  nextPointId: number; // The least positive integer not in pointIdsInUse.\n  treePoints: Map<any, any>; // Map from all points to set of incident lines.\n  edgeLengthLabelOf: Map<any, any>; // Map from each line to its edge length label.\n  adjustVerts: any;\n  adjustPt: any;\n  adjustAngle: any;\n  treeBoard: Board | null;\n  undoPoints: Array<TreeGraph>;\n  currentUndoPoint: number;\n\n  constructor() {\n    super();\n\n    // ugh, apparently i need to copy/paste this because typescript isn't smart enough to realize resetState() assigns to these -alt\n    this.readyToCreateNewPoint = true;\n    this.pointIdsInUse = new Set();\n    this.nextPointId = 1;\n    this.edgeLengthLabelOf = new Map();\n    this.treePoints = new Map();\n    this.edgeLengthLabelOf = new Map();\n    this.adjustVerts = undefined;\n    this.adjustPt = undefined;\n    this.adjustAngle = undefined;\n\n    this.treeBoard = null;\n    this.undoPoints = [];\n    this.currentUndoPoint = 0;\n  }\n\n  resetState() {\n    this.readyToCreateNewPoint = true; // Lock to make sure we don't try to create several new points in one ctrl press.\n    this.pointIdsInUse = new Set();\n    this.nextPointId = 1;\n    this.edgeLengthLabelOf = new Map();\n    this.treePoints = new Map();\n    this.edgeLengthLabelOf = new Map();\n    this.adjustVerts = undefined;\n    this.adjustPt = undefined;\n    this.adjustAngle = undefined;\n  }\n\n  mounted() {\n    this.treeBoard = JSXGraph.initBoard(\"treeViewBox\", {\n      boundingbox: [0, 10, 10, 0],\n      showCopyright: false\n    });\n\n    const initialPoint1 = this.createPoint(5, 4);\n    const initialPoint2 = this.createPoint(5, 6);\n    this.treePoints.set(initialPoint1, new Set());\n    this.treePoints.set(initialPoint2, new Set());\n    this.createLine(initialPoint1, initialPoint2);\n\n    // undo/redo\n    this.setUndoPoint(true);\n    window.addEventListener(\"keydown\", e => {\n      if (\n        e.ctrlKey &&\n        e.key === \"y\" &&\n        this.currentUndoPoint < this.undoPoints.length - 1\n      ) {\n        this.deserialize(this.undoPoints[++this.currentUndoPoint]);\n      } else if (e.ctrlKey && e.key === \"z\" && this.currentUndoPoint > 0) {\n        this.deserialize(this.undoPoints[--this.currentUndoPoint]);\n      }\n    });\n\n    // adjust\n    this.treeBoard.on(\"move\", e => {\n      if (!this.adjustVerts) return;\n      const [cx, cy] = this.toCoords(e),\n        newAngle = Math.atan2(cy - this.adjustPt[1], cx - this.adjustPt[0]),\n        s = Math.sin(newAngle - this.adjustAngle),\n        c = Math.cos(newAngle - this.adjustAngle);\n      for (const pt of this.adjustVerts) {\n        pt.v.moveTo([\n          c * (pt.orig[0] - this.adjustPt[0]) -\n            s * (pt.orig[1] - this.adjustPt[1]) +\n            this.adjustPt[0] +\n            pt.offset[0],\n          s * (pt.orig[0] - this.adjustPt[0]) +\n            c * (pt.orig[1] - this.adjustPt[1]) +\n            this.adjustPt[1] +\n            pt.offset[1]\n        ]);\n      }\n    });\n  }\n\n  serialize(): TreeGraph {\n    const tree = new TreeGraph();\n    const newPoints = new Map();\n\n    // Generate nodes.\n    this.treePoints.forEach(function(edges: any, point: any) {\n      const px = point.X();\n      const py = point.Y();\n      const v = new TreeNode(point.name.toString(), px, py);\n      tree.addNode(v);\n      newPoints.set([px, py].toString(), v);\n    });\n\n    // Generate deduplicated edges.\n    const seen = new Set();\n    this.treePoints.forEach(function(edges: any) {\n      for (const edge of edges) {\n        const p1 = edge.point1;\n        const p2 = edge.point2;\n        const p1x = p1.X();\n        const p1y = p1.Y();\n        const p2x = p2.X();\n        const p2y = p2.Y();\n        if (\n          !seen.has([p1x, p1y, p2x, p2y].toString()) &&\n          !seen.has([p2x, p2y, p1x, p1y].toString())\n        ) {\n          const v1 = newPoints.get([p1x, p1y].toString());\n          const v2 = newPoints.get([p2x, p2y].toString());\n          const length = Math.sqrt(\n            Math.pow(p1x - p2x, 2) + Math.pow(p1y - p2y, 2)\n          );\n          const edge = new TreeEdge(v1, v2, length);\n          tree.addEdge(edge);\n          seen.add([p1x, p1y, p2x, p2y].toString());\n          seen.add([p2x, p2y, p1x, p1y].toString());\n        }\n      }\n    });\n\n    return tree;\n  }\n\n  deserialize(tree: TreeGraph) {\n    this.treeBoard.suspendUpdate();\n\n    this.treeBoard.removeObject(Array.from(this.treeBoard.objectsList));\n    this.resetState();\n\n    const nodeToPoint = new Map();\n\n    tree.nodes.forEach(node => {\n      const point = this.createPoint(node.x, node.y, parseInt(node.id));\n      this.treePoints.set(point, new Set());\n      nodeToPoint.set(node.id, point);\n    });\n    this.resetNextPointId();\n\n    tree.edges.forEach(edge => {\n      this.createLine(\n        nodeToPoint.get(edge.to.id),\n        nodeToPoint.get(edge.from.id)\n      );\n    });\n\n    this.treeBoard.unsuspendUpdate();\n  }\n\n  setUndoPoint(first?: boolean) {\n    const tree: TreeGraph = this.serialize();\n    if (first) {\n      this.undoPoints = [tree];\n    } else {\n      if (this.currentUndoPoint != this.undoPoints.length - 1) {\n        this.undoPoints = this.undoPoints.slice(0, this.currentUndoPoint + 1);\n      }\n      this.undoPoints.push(tree);\n      ++this.currentUndoPoint;\n    }\n  }\n\n  propagate() {\n    /* Update the global state with a `TreeGraph` representation. */\n    this.$store.commit(\n      \"updateTreeGraph\",\n      this.undoPoints[this.currentUndoPoint]\n    );\n  }\n\n  findSubtree(\n    vertices: any[],\n    edges: Set<any>,\n    fromPoint: any,\n    toPoint: any\n  ): any[] {\n    vertices.push(toPoint);\n    for (const incidentLine of this.treePoints.get(toPoint)) {\n      edges.add(incidentLine);\n      for (const otherPoint of [incidentLine.point1, incidentLine.point2]) {\n        if (otherPoint != fromPoint && otherPoint != toPoint) {\n          this.findSubtree(vertices, edges, toPoint, otherPoint);\n        }\n      }\n    }\n    return [vertices, edges];\n  }\n\n  changeEdgeLength(point1: any, point2: any) {\n    const newDistance = Number(\n      prompt(\n        \"Distance between point \" +\n          point1.name +\n          \" and point \" +\n          point2.name +\n          \":\",\n        \"\"\n      )\n    );\n    if (newDistance > 0) {\n      const oldDistance = point1.Dist(point2);\n      const xGap = point2.X() - point1.X();\n      const yGap = point2.Y() - point1.Y();\n      let dx = (xGap * newDistance) / oldDistance - xGap;\n      let dy = (yGap * newDistance) / oldDistance - yGap;\n      const subtree1 = this.findSubtree([], new Set(), point2, point1)[0];\n      const subtree2 = this.findSubtree([], new Set(), point1, point2)[0];\n      let smallerSubtree;\n      if (subtree1.length < subtree2.length) {\n        smallerSubtree = subtree1;\n        dx = -dx;\n        dy = -dy;\n      } else {\n        smallerSubtree = subtree2;\n      }\n      for (const point of smallerSubtree) {\n        point.setPosition(COORDS_BY_USER, [point.X() + dx, point.Y() + dy]);\n      }\n      this.setUndoPoint();\n    }\n  }\n\n  // Removes a line from the treeBoard.\n  deleteLine(incidentLine: any) {\n    for (const endPoint of [incidentLine.point1, incidentLine.point2]) {\n      const setOfIncidentEdges = this.treePoints.get(endPoint);\n      setOfIncidentEdges.delete(incidentLine);\n    }\n    this.treeBoard.removeObject(incidentLine);\n    const edgeLengthLabel = this.edgeLengthLabelOf.get(incidentLine);\n    this.treeBoard.removeObject(edgeLengthLabel);\n    this.edgeLengthLabelOf.delete(incidentLine);\n  }\n\n  // Removes the smaller component of T \\ {{point1, point2}} from the treeBoard.\n  deleteSubtree(point1: any, point2: any) {\n    const [subtree1Vertices, subtree1Edges] = this.findSubtree(\n      [],\n      new Set(),\n      point2,\n      point1\n    );\n    const [subtree2Vertices, subtree2Edges] = this.findSubtree(\n      [],\n      new Set(),\n      point1,\n      point2\n    );\n    let smallerSubtreeVertices;\n    let smallerSubtreeEdges;\n    if (subtree1Vertices.length < subtree2Vertices.length) {\n      smallerSubtreeVertices = subtree1Vertices;\n      smallerSubtreeEdges = subtree1Edges;\n    } else {\n      smallerSubtreeVertices = subtree2Vertices;\n      smallerSubtreeEdges = subtree2Edges;\n    }\n    for (const line of smallerSubtreeEdges) {\n      this.deleteLine(line);\n    }\n    for (const point of smallerSubtreeVertices) {\n      this.pointIdsInUse.delete(point.name);\n      this.treeBoard.removeObject(point);\n      this.treePoints.delete(point);\n    }\n    this.resetNextPointId();\n    this.setUndoPoint();\n  }\n\n  // Creates a line between point1 and point2.\n  createLine(point1: any, point2: any): any {\n    const newLine = this.treeBoard.create(\"segment\", [point1, point2], {\n      fixed: true\n    });\n    const newLineEdgeLengthLabel = this.treeBoard.create(\n      \"text\",\n      [\n        function(x: any) {\n          return (point1.X() + point2.X()) / 2;\n        },\n        function(x: any) {\n          return (point1.Y() + point2.Y()) / 2;\n        },\n        function() {\n          return point1.Dist(point2).toFixed(2);\n        }\n      ],\n      { highlight: false }\n    );\n    this.treePoints.get(point1).add(newLine);\n    this.treePoints.get(point2).add(newLine);\n    this.edgeLengthLabelOf.set(newLine, newLineEdgeLengthLabel);\n\n    newLine.on(\n      \"up\",\n      function(this: TreeView, e) {\n        if (this.adjustVerts) {\n          this.adjustVerts = undefined;\n          this.adjustPt = undefined;\n          this.adjustAngle = undefined;\n          this.setUndoPoint();\n        } else if (e.shiftKey) this.deleteSubtree(point1, point2);\n      }.bind(this)\n    );\n\n    newLine.on(\n      \"down\",\n      function(this: TreeView, e) {\n        if (e.which === 3) this.changeEdgeLength(point1, point2);\n        if (e.altKey) {\n          const [cx, cy] = this.toCoords(e),\n            distsq1 =\n              Math.pow(point1.X() - cx, 2) + Math.pow(point1.Y() - cy, 2),\n            distsq2 =\n              Math.pow(point2.X() - cx, 2) + Math.pow(point2.Y() - cy, 2),\n            centerPoint = distsq1 < distsq2 ? point2 : point1,\n            otherPoint = distsq1 < distsq2 ? point1 : point2,\n            [verts, _] = this.findSubtree(\n              [],\n              new Set(),\n              centerPoint,\n              otherPoint\n            );\n          this.adjustVerts = verts.map(v => ({\n            orig: e.ctrlKey ? [otherPoint.X(), otherPoint.Y()] : [v.X(), v.Y()],\n            offset: e.ctrlKey\n              ? [v.X() - otherPoint.X(), v.Y() - otherPoint.Y()]\n              : [0, 0],\n            v: v\n          }));\n          this.adjustPt = [centerPoint.X(), centerPoint.Y()];\n          this.adjustAngle = Math.atan2(\n            cy - centerPoint.Y(),\n            cx - centerPoint.X()\n          );\n        }\n      }.bind(this)\n    );\n\n    return newLine;\n  }\n\n  // Creates a point at the given user coordinates.\n  createPoint(x: any, y: any, forceName?: number): any {\n    const name = forceName || this.nextPointId;\n    const point = this.treeBoard.create(\"point\", [x, y], {\n      name: name,\n      label: { offset: [6, 6], highlight: false }\n    });\n    point.on(\n      \"up\",\n      function(this: TreeView, e: any) {\n        if (this.readyToCreateNewPoint) this.setUndoPoint();\n        this.readyToCreateNewPoint = true;\n      }.bind(this)\n    );\n    point.on(\n      \"down\",\n      function(this: TreeView, e: any) {\n        if (e.ctrlKey && this.readyToCreateNewPoint) {\n          this.readyToCreateNewPoint = false;\n          const newPoint = this.createPoint(point.X(), point.Y());\n          this.treePoints.set(newPoint, new Set());\n\n          // Redraw lines to new point.\n          const incidentLines: Set<any> = new Set(this.treePoints.get(point));\n          for (const incidentLine of incidentLines) {\n            let otherPoint = null;\n            if (incidentLine.point1 === point) {\n              otherPoint = incidentLine.point2;\n            } else if (incidentLine.point2 === point) {\n              otherPoint = incidentLine.point1;\n            } else {\n              console.log(\"Error: Line in treePoints not incident.\");\n              console.log(point.name);\n              console.log(incidentLine.point1.name);\n              console.log(incidentLine.point2.name);\n            }\n            this.deleteLine(incidentLine);\n            this.createLine(otherPoint, point); // TODO If it stops switching the element being dragged, change point to newPoint and take out the break.\n            break;\n          }\n          this.createLine(point, newPoint);\n        }\n      }.bind(this)\n    );\n    this.pointIdsInUse.add(name);\n    if (!forceName) {\n      while (this.pointIdsInUse.has(this.nextPointId)) {\n        this.nextPointId++;\n      }\n    }\n    return point;\n  }\n\n  resetNextPointId() {\n    this.nextPointId = 1;\n    while (this.pointIdsInUse.has(this.nextPointId)) {\n      this.nextPointId++;\n    }\n  }\n\n  // TODO doesn't handle multitouch properly, see https://jsxgraph.uni-bayreuth.de/wiki/index.php/Browser_event_and_coordinates -alt\n  toCoords(e): any[] {\n    const p1 = this.treeBoard.getCoordsTopLeftCorner(e, 0),\n      p2 = getPosition(e),\n      coords = new Coords(\n        COORDS_BY_SCREEN,\n        [p2[0] - p1[0], p2[1] - p1[1]],\n        this.treeBoard\n      );\n    return [coords.usrCoords[1], coords.usrCoords[2]];\n  }\n}\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./TreeView.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./TreeView.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./TreeView.vue?vue&type=template&id=07ba2c02&\"\nimport script from \"./TreeView.vue?vue&type=script&lang=ts&\"\nexport * from \"./TreeView.vue?vue&type=script&lang=ts&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"viewBox\",attrs:{\"id\":\"creasesViewBox\"}})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","/* eslint-disable @typescript-eslint/camelcase */\n/**\n * Helper functions for exporting a crease pattern to the FOLD format.\n */\nimport {\n  CreasesGraph,\n  CreasesNode,\n  Crease,\n  CreaseType,\n  MVAssignment,\n  Face\n} from \"../packing\";\n\nfunction edgeAssignmentShort(e: Crease, fanOutHinges: boolean): string {\n  if (fanOutHinges && e.creaseType == CreaseType.Hinge) {\n    return \"B\"; // Setting fanOutHinges true makes all hinges unassigned.\n  }\n  switch (e.assignment) {\n    case MVAssignment.Mountain:\n      return \"M\";\n    case MVAssignment.Valley:\n      return \"V\";\n    case MVAssignment.Unfolded:\n      return \"F\";\n  }\n  return \"B\";\n}\n\nexport function generateFold(graph: CreasesGraph) {\n  const coords: [number, number][] = [];\n  const edges: [number, number][] = [];\n  const assignments: string[] = [];\n  const angles: (number | null)[] = [];\n  const faceVertices: number[][] = [];\n\n  const vertexOrder = Array.from(graph.nodes.keys()).sort();\n  const edgeOrder = Array.from(graph.edges.keys()).sort();\n  const vertexEdges: number[][] = vertexOrder.map(x => []);\n\n  for (const vid of vertexOrder) {\n    const node = graph.nodes.get(vid) as CreasesNode;\n    coords.push([node.x, node.y]);\n  }\n  for (const [idx, eid] of edgeOrder.entries()) {\n    const edge = graph.edges.get(eid) as Crease;\n\n    // TODO (@pjrule): these lookups could be sped up.\n    const toIdx = vertexOrder.indexOf(edge.to.id);\n    const fromIdx = vertexOrder.indexOf(edge.from.id);\n    vertexEdges[toIdx].push(idx);\n    vertexEdges[fromIdx].push(idx);\n    edges.push([toIdx, fromIdx]);\n    const assn = edgeAssignmentShort(edge, true); // TODO Make second argument a user choice.\n    assignments.push(assn);\n    // Origami Simulator does not automatically infer fold angles upon a POST request,\n    // so we generate them manually. See https://github.com/amandaghassaei/\n    // OrigamiSimulator/blob/539f1cd4eaa8b7b631f1697b54dc726409e33799/js/importer.js\n    if (assn === \"M\") {\n      angles.push(-180);\n    } else if (assn === \"V\") {\n      angles.push(180);\n    } else if (assn === \"F\") {\n      angles.push(0);\n    } else {\n      angles.push(null);\n    }\n  }\n  for (const face of graph.faces) {\n    if (!face.isOuterFace) {\n      const nodeIds: number[] = [];\n      const reversedNodes: CreasesNode[] = Object.assign(\n        [],\n        face.nodes\n      ).reverse();\n      for (const faceNode of reversedNodes) {\n        const vid = vertexOrder.indexOf(faceNode.id);\n        nodeIds.push(vid);\n      }\n      faceVertices.push(nodeIds);\n    }\n  }\n\n  return {\n    file_spec: \"1.1\",\n    file_creator: \"TreeFaker\",\n    file_classes: [\"creasePattern\"],\n    vertices_coords: coords,\n    edges_vertices: edges,\n    edges_assignment: assignments,\n    edges_foldAngle: angles,\n    vertices_edges: vertexEdges,\n    faces_vertices: faceVertices\n  };\n}\n","import {\n  TOLERANCE,\n  BINARY_SEARCH_TOLERANCE,\n  UPDATE_TOLERANCE,\n  IS_RIGHT_TURN_CUTOFF_1,\n  IS_RIGHT_TURN_CUTOFF_2,\n  IS_RIGHT_TURN_CUTOFF_3,\n  IS_RIGHT_TURN_CUTOFF_4,\n  getAnyElement,\n  Node,\n  Edge,\n  Face,\n  TreeNode,\n  TreeEdge,\n  PackingNode,\n  Packing,\n  CreasesNode,\n  CreaseType,\n  MVAssignment,\n  Crease,\n  Graph,\n  TreeGraph,\n  CreasesGraphState,\n  CreasesGraph\n} from \"../packing\";\n\n// Returns the minimum distance enforced by the tree constraints in paper-units.\nfunction activeDistance(\n  v1: CreasesNode,\n  v2: CreasesNode,\n  scaleFactor: number,\n  d: Map<string, Map<string, Array<[string, number]>>>,\n  leafExtensions: Map<CreasesNode, number>\n) {\n  const distancesAlongPath = (d.get(v1.id) as Map<\n    string,\n    Array<[string, number]>\n  >).get(v2.id) as Array<[string, number]>;\n  const distanceAlongPath = distancesAlongPath[\n    distancesAlongPath.length - 1\n  ][1] as number;\n  return (\n    scaleFactor *\n    (distanceAlongPath +\n      (leafExtensions.get(v1) as number) +\n      (leafExtensions.get(v2) as number))\n  );\n}\n\n// Returns whether a path is active, throwing an error if the distance constraint is violated.\nfunction isActive(\n  v1: CreasesNode,\n  v2: CreasesNode,\n  scaleFactor: number,\n  d: Map<string, Map<string, Array<[string, number]>>>,\n  leafExtensions: Map<CreasesNode, number>,\n  tolerance: number\n) {\n  const xDistance = v2.x - v1.x;\n  const yDistance = v2.y - v1.y;\n  const distanceOnPlane = Math.sqrt(\n    xDistance * xDistance + yDistance * yDistance\n  );\n  //console.log(`v1.id: ${v1.id}  v2.id: ${v2.id}`);\n  //console.log(`Computing isActive - Distance on plane: ${distanceOnPlane}  Active distance: ${activeDistance(v1, v2, scaleFactor, d, leafExtensions)}`)\n  const slack =\n    distanceOnPlane - activeDistance(v1, v2, scaleFactor, d, leafExtensions);\n  if (slack < -tolerance) {\n    console.log(\n      `distanceOnPlane: ${distanceOnPlane}    activeDIstance: ${activeDistance(\n        v1,\n        v2,\n        scaleFactor,\n        d,\n        leafExtensions\n      )}`\n    );\n    throw new Error(\n      `Insufficient slack of ${slack} between nodes '${v1.id}' and '${v2.id}'.`\n    );\n  } else {\n    return slack < tolerance;\n  }\n}\n\n// Using formula and notation from: https://mathworld.wolfram.com/Circle-CircleIntersection.html\nexport function get2CircleIntersection(\n  x1: number,\n  y1: number,\n  r1: number,\n  x2: number,\n  y2: number,\n  r2: number,\n  onLeftSide: boolean\n) {\n  const r1Squared = r1 * r1;\n  const r2Squared = r2 * r2;\n  const parallelX = x2 - x1;\n  const parallelY = y2 - y1;\n  const perpendicularX = onLeftSide ? -parallelY : parallelY;\n  const perpendicularY = onLeftSide ? parallelX : -parallelX;\n  const dSquared = parallelX * parallelX + parallelY * parallelY;\n  const twoDSquared = 2 * dSquared;\n  //const d = Math.sqrt(dSquared);\n  const t = dSquared - r2Squared + r1Squared;\n  const parallelDistanceScaled = t / twoDSquared; // AKA \"x/d\" from Wolfram site.\n  const perpendicularDistanceScaled =\n    Math.sqrt(4 * dSquared * r1Squared - t * t) / twoDSquared; // AKA \"y/d\" from Wolfram site.\n  const x =\n    x1 +\n    parallelX * parallelDistanceScaled +\n    perpendicularX * perpendicularDistanceScaled;\n  const y =\n    y1 +\n    parallelY * parallelDistanceScaled +\n    perpendicularY * perpendicularDistanceScaled;\n  return [x, y];\n}\n\n// Returns a pair of adjacent nodes that forms a convex angle on one side, if it exists.\nexport function getIndexOfConvexGap(v: Node) {\n  const numEdges = v.edges.length;\n  if (numEdges < 2) {\n    throw new Error(`There are ${numEdges} edges incident to Node ${v.id}.`);\n  }\n  for (let index = 0; index < numEdges; index++) {\n    const e1 = v.edges[index] as Edge;\n    const e2 = v.edges[(index + 1) % numEdges] as Edge;\n    const v1 = e1.getOtherNode(v);\n    const v2 = e2.getOtherNode(v);\n    const v1Angle = Math.atan2(v1.y - v.y, v1.x - v.x);\n    let v2Angle = Math.atan2(v2.y - v.y, v2.x - v.x);\n    if (v2Angle < v1Angle) {\n      v2Angle += 2 * Math.PI;\n    }\n    const angleDifference = v2Angle - v1Angle;\n    //console.log(`Angle difference: ${angleDifference}`);\n    if (angleDifference > Math.PI + TOLERANCE) {\n      return [index, v1, v2];\n    }\n  }\n  return [null, null, null];\n}\n\n// Makes leafs longer so that all active polygons are convex.\nexport function cleanPacking(\n  p: Packing,\n  d: Map<string, Map<string, Array<[string, number]>>>\n): CreasesGraph {\n  if (p.nodes.size < 2) {\n    throw new Error(\"Must have at least two nodes in packing.\");\n  }\n\n  // Make creases graph with Axial creases along each active path.\n  const g = new CreasesGraph(p);\n  for (const v1 of g.nodes.values()) {\n    for (const v2 of g.nodes.values()) {\n      if (\n        v1.id < v2.id &&\n        isActive(v1, v2, p.scaleFactor, d, g.leafExtensions, TOLERANCE)\n      ) {\n        const axialCrease = new Crease(v2, v1, CreaseType.Axial, null);\n        g.addEdge(axialCrease);\n      }\n    }\n  }\n  const nodeQueue = new Set(g.nodes.values());\n\n  // This function will be called repeatedly to reposition a vertex and recompute what paths are active.\n  function updateNode(v: CreasesNode, r: number, x: number, y: number) {\n    // Add leaf extension.\n    const oldLeafExtension = g.leafExtensions.get(v) as number;\n    g.leafExtensions.set(v, oldLeafExtension + r / p.scaleFactor);\n\n    // Move vertex v to new position in packing and creases graph.\n    (p.nodes.get(v.id) as PackingNode).x = x;\n    (p.nodes.get(v.id) as PackingNode).y = y;\n    v.x = x;\n    v.y = y;\n    v.onBoundaryOfSquare =\n      v.x < TOLERANCE ||\n      v.y < TOLERANCE ||\n      v.x > 1 - TOLERANCE ||\n      v.y > 1 - TOLERANCE;\n\n    // Recompute active paths.\n    for (const e of [...v.edges]) {\n      nodeQueue.add(e.getOtherNode(v) as CreasesNode);\n      g.removeEdge(e as Crease);\n    }\n    for (const u of g.nodes.values()) {\n      if (\n        u != v &&\n        isActive(v, u, p.scaleFactor, d, g.leafExtensions, UPDATE_TOLERANCE)\n      ) {\n        const axialCrease = new Crease(v, u, CreaseType.Axial, null);\n        g.addEdge(axialCrease);\n      }\n    }\n  }\n\n  // Main loop, tries to clean packing until the nodeQueue is empty, which means there are no more potential problems.\n  for (let numIterations = 0; numIterations < 500; numIterations++) {\n    if (nodeQueue.size == 0) {\n      g.state = CreasesGraphState.Clean;\n      return g;\n    } else {\n      const v = getAnyElement(nodeQueue);\n      nodeQueue.delete(v);\n      const numActivePaths = v.edges.length;\n      if (numActivePaths == 0) {\n        // No active paths, so expand in place until we get an active path.\n        let rOpt = 2;\n        for (const possibleConstraintVertex of g.nodes.values()) {\n          if (possibleConstraintVertex != v) {\n            const xDistance = possibleConstraintVertex.x - v.x;\n            const yDistance = possibleConstraintVertex.y - v.y;\n            const distanceOnPlane = Math.sqrt(\n              xDistance * xDistance + yDistance * yDistance\n            );\n            const r =\n              distanceOnPlane -\n              activeDistance(\n                v,\n                possibleConstraintVertex,\n                p.scaleFactor,\n                d,\n                g.leafExtensions\n              );\n            if (r < rOpt) {\n              rOpt = r;\n            }\n          }\n        }\n        if (rOpt == 2) {\n          throw new Error(\"Did not find a new binding constraint.\");\n        } else if (rOpt <= 0) {\n          throw new Error(\"Should have detected active path earlier.\");\n        }\n        //console.log(`Updating node from case 1:  v: ${v.id}  rOpt: ${rOpt/p.scaleFactor}`);\n        updateNode(v, rOpt, v.x, v.y);\n        nodeQueue.add(v);\n      } else if (!v.onBoundaryOfSquare) {\n        if (numActivePaths == 1) {\n          // Only one active path, so expand along ray away from it until we hit another constraint.\n          const x1 = v.x;\n          const y1 = v.y;\n          const u = v.edges[0].getOtherNode(v);\n          const vectorFromActivePathX = x1 - u.x;\n          const vectorFromActivePathY = y1 - u.y;\n          const vectorFromActivePathLength = Math.sqrt(\n            vectorFromActivePathX * vectorFromActivePathX +\n              vectorFromActivePathY * vectorFromActivePathY\n          );\n          const dx = vectorFromActivePathX / vectorFromActivePathLength;\n          const dy = vectorFromActivePathY / vectorFromActivePathLength;\n          let rOpt = 2;\n          let xOpt = -1;\n          let yOpt = -1;\n\n          // Check for active path constraints; based on 11-23-2020 whiteboard picture.\n          for (const possibleConstraintVertex of g.nodes.values()) {\n            if (\n              possibleConstraintVertex != v &&\n              possibleConstraintVertex != u\n            ) {\n              const x2 = possibleConstraintVertex.x;\n              const y2 = possibleConstraintVertex.y;\n              const xDiff = x1 - x2;\n              const yDiff = y1 - y2;\n              const r2 = activeDistance(\n                v,\n                possibleConstraintVertex,\n                p.scaleFactor,\n                d,\n                g.leafExtensions\n              );\n              const r =\n                (r2 * r2 - xDiff * xDiff - yDiff * yDiff) /\n                (2 * (dx * xDiff + dy * yDiff - r2));\n              //console.log(`Checking constraint on vertex ${possibleConstraintVertex.id}:  r = ${r/p.scaleFactor}`);\n              if (0 < r && r < rOpt) {\n                //console.log(`Updating rOpt = ${r/p.scaleFactor} from vertex ${possibleConstraintVertex.id} collision condition`);\n                rOpt = r;\n                xOpt = x1 + r * dx;\n                yOpt = y1 + r * dy;\n              }\n            }\n          }\n\n          // Check x boundary conditions.\n          if (Math.abs(dx) > TOLERANCE) {\n            for (const r of [-x1 / dx, (1 - x1) / dx]) {\n              if (0 < r && r < rOpt) {\n                //console.log(`Updating rOpt = ${r/p.scaleFactor} from x boundary condition`);\n                rOpt = r;\n                xOpt = x1 + r * dx;\n                yOpt = y1 + r * dy;\n              }\n            }\n          }\n\n          // Check y boundary conditions.\n          if (Math.abs(dy) > TOLERANCE) {\n            for (const r of [-y1 / dy, (1 - y1) / dy]) {\n              if (0 < r && r < rOpt) {\n                //console.log(`Updating rOpt = ${r/p.scaleFactor} from y boundary condition`);\n                rOpt = r;\n                xOpt = x1 + r * dx;\n                yOpt = y1 + r * dy;\n              }\n            }\n          }\n          if (rOpt == 2) {\n            throw new Error(\"Did not find a new binding constraint.\");\n          }\n          //console.log(`Updating node from case 2:  v: ${v.id}  rOpt: ${rOpt/p.scaleFactor}  xOpt: ${xOpt/p.scaleFactor}  yOpt: ${yOpt/p.scaleFactor}`);\n          updateNode(v, rOpt, xOpt, yOpt);\n          nodeQueue.add(v);\n        } else {\n          const [indexOfConvexGap, v1t, v2t] = getIndexOfConvexGap(v);\n          if (indexOfConvexGap != null) {\n            // We potentially have a non-convex active polygon, so expand both circles simultaneously.\n            const v1 = v1t as CreasesNode;\n            const v2 = v2t as CreasesNode;\n            const x1 = v1.x;\n            const y1 = v1.y;\n            const x2 = v2.x;\n            const y2 = v2.y;\n            const baseR1 = activeDistance(\n              v,\n              v1,\n              p.scaleFactor,\n              d,\n              g.leafExtensions\n            );\n            const baseR2 = activeDistance(\n              v,\n              v2,\n              p.scaleFactor,\n              d,\n              g.leafExtensions\n            );\n            const parallelX = x2 - x1;\n            const parallelY = y2 - y1;\n            const leftX = -parallelY;\n            const leftY = parallelX;\n            const onLeftSide = (v.x - v1.x) * leftX + (v.y - v1.y) * leftY > 0;\n            const possibleConstraintVertices = new Set(\n              Array.from(g.nodes.values())\n            );\n            possibleConstraintVertices.delete(v);\n            for (const neighboringEdge of v.edges) {\n              possibleConstraintVertices.delete(\n                neighboringEdge.getOtherNode(v) as CreasesNode\n              );\n            }\n\n            // Binary search for smallest leaf radius we can legally add.\n            let r = 1;\n            for (let dr = 0.5; dr > BINARY_SEARCH_TOLERANCE; dr = dr / 2) {\n              const [x, y] = get2CircleIntersection(\n                x1,\n                y1,\n                baseR1 + r,\n                x2,\n                y2,\n                baseR2 + r,\n                onLeftSide\n              );\n              let constraintViolated = x < 0 || y < 0 || x > 1 || y > 1;\n              if (!constraintViolated) {\n                for (const possibleConstraintVertex of possibleConstraintVertices) {\n                  const xDistance = possibleConstraintVertex.x - x;\n                  const yDistance = possibleConstraintVertex.y - y;\n                  const distanceOnPlane = Math.sqrt(\n                    xDistance * xDistance + yDistance * yDistance\n                  );\n                  if (\n                    distanceOnPlane <\n                    activeDistance(\n                      v,\n                      possibleConstraintVertex,\n                      p.scaleFactor,\n                      d,\n                      g.leafExtensions\n                    ) +\n                      r\n                  ) {\n                    constraintViolated = true;\n                    break;\n                  }\n                }\n              }\n              if (constraintViolated) {\n                r -= dr;\n              } else {\n                r += dr;\n              }\n            }\n            const [x, y] = get2CircleIntersection(\n              x1,\n              y1,\n              baseR1 + r,\n              x2,\n              y2,\n              baseR2 + r,\n              onLeftSide\n            );\n            //console.log(`Updating node from case 3:  v: ${v.id}  r: ${r/p.scaleFactor}  x: ${x/p.scaleFactor}  y: ${y/p.scaleFactor}`);\n            updateNode(v, r, x, y);\n            nodeQueue.add(v);\n          }\n        }\n      }\n    }\n  }\n  throw new Error(\"Caught in infinite loop while cleaning packing.\");\n}\n\n// Returns whether v1-v2-v3 makes a right turn, and whether it is close to 180 degrees.\nexport function isRightTurn(v1, v2, v3) {\n  const v1Angle = Math.atan2(v1.y - v2.y, v1.x - v2.x);\n  const v3Angle = Math.atan2(v3.y - v2.y, v3.x - v2.x);\n  const angleDifference = v3Angle - v1Angle;\n  if (angleDifference < 0) {\n    return [\n      angleDifference < IS_RIGHT_TURN_CUTOFF_1,\n      angleDifference > -TOLERANCE || angleDifference < IS_RIGHT_TURN_CUTOFF_3\n    ];\n  } else {\n    return [\n      angleDifference < IS_RIGHT_TURN_CUTOFF_2,\n      angleDifference < TOLERANCE || angleDifference > IS_RIGHT_TURN_CUTOFF_4\n    ];\n  }\n}\n\n// Builds a face for each active polygon. Returns an error message as a string if there are at least two inactive hull creases. Returns null if there are no errors.\nexport function buildFaces(g: CreasesGraph): null | string {\n  if (g.state != CreasesGraphState.Clean) {\n    throw new Error(\n      `Should not be calling buildFaces from state ${\n        CreasesGraphState[g.state]\n      }.`\n    );\n  }\n\n  // Compute convex hull using Graham Scan with tolerance.\n  let leastX = 2;\n  let leastXVertex: null | CreasesNode = null;\n  const points: Array<CreasesNode> = [];\n  for (const v of g.nodes.values()) {\n    if (v.x < leastX) {\n      if (leastXVertex != null) {\n        points.push(leastXVertex);\n      }\n      leastX = v.x;\n      leastXVertex = v;\n    } else {\n      points.push(v);\n    }\n  }\n  if (leastXVertex == null) {\n    throw new Error(\"Bad node x values.\");\n  }\n  const v0 = leastXVertex as CreasesNode;\n  points.sort(function(v1, v2) {\n    const v1Angle = Math.atan2(v1.y - v0.y, v1.x - v0.x);\n    const v2Angle = Math.atan2(v2.y - v0.y, v2.x - v0.x);\n    return v2Angle - v1Angle;\n  });\n  const convexHull = [v0];\n  let stillComputingConvexHull = true;\n  for (let numIterations = 0; numIterations < 200; numIterations++) {\n    if (points.length == 0) {\n      stillComputingConvexHull = false;\n      break;\n    }\n    const point = points.pop() as CreasesNode;\n    while (convexHull.length > 1) {\n      const [isRight, is180] = isRightTurn(\n        convexHull[convexHull.length - 2],\n        convexHull[convexHull.length - 1],\n        point\n      );\n      if (isRight) {\n        const removedPoint = convexHull.pop() as CreasesNode;\n        if (is180) {\n          points.push(removedPoint); // This is the key difference from ordinary Graham scan.\n        }\n      } else {\n        break;\n      }\n    }\n    convexHull.push(point);\n  }\n  if (stillComputingConvexHull) {\n    throw new Error(\"Caught in infinite loop while computing convex hull.\");\n  }\n\n  // Set hull creases.\n  for (let i = 0; i < convexHull.length; i++) {\n    const v1 = convexHull[i] as CreasesNode;\n    const v2 = convexHull[(i + 1) % convexHull.length] as CreasesNode;\n    const e = g.getEdge(v1, v2);\n    if (e == undefined) {\n      g.addEdge(new Crease(v2, v1, CreaseType.InactiveHull, null));\n    } else {\n      e.updateCreaseType(CreaseType.ActiveHull);\n    }\n  }\n\n  // Construct faces.\n  let foundOuterFace = false;\n  const undiscoveredEdges = new Set(g.edges.values());\n  const edgeQueue: Set<Crease> = new Set();\n  const firstVertexOfConvexHull = convexHull[0] as CreasesNode;\n  const secondVertexOfConvexHull = convexHull[1] as CreasesNode;\n  const firstEdgeOfConvexHull = g.getEdge(\n    firstVertexOfConvexHull,\n    secondVertexOfConvexHull\n  ) as Crease;\n  edgeQueue.add(firstEdgeOfConvexHull);\n  undiscoveredEdges.delete(firstEdgeOfConvexHull);\n  function fillInFaceToTheLeft(\n    vStart: CreasesNode,\n    eStart: Crease\n  ): null | string {\n    const face = new Face();\n    g.faces.add(face);\n    if (\n      eStart == firstEdgeOfConvexHull &&\n      eStart.getOtherNode(vStart) == firstVertexOfConvexHull\n    ) {\n      if (foundOuterFace) {\n        throw new Error(\"Already found outer face.\");\n      }\n      face.isOuterFace = true;\n      foundOuterFace = true;\n    }\n    let v = vStart;\n    let e = eStart;\n    for (let numIterations = 0; numIterations < 100; numIterations++) {\n      face.nodes.push(v);\n      if (v == e.from) {\n        if (e.leftFace == null) {\n          e.leftFace = face;\n        } else {\n          throw new Error(\n            `Left face has already been set for edge ${e.idString()}.`\n          );\n        }\n      } else {\n        if (e.right == null) {\n          e.rightFace = face;\n        } else {\n          throw new Error(\n            `Right face has already been set for edge ${e.idString()}.`\n          );\n        }\n      }\n      if (e.creaseType == CreaseType.InactiveHull) {\n        if (!face.isOuterFace) {\n          if (face.inactiveHullEdge == null) {\n            face.inactiveHullEdge = e;\n          } else {\n            return `Face ${face.nodes.map(\n              n => n.id\n            )} has at least two inactive hull edges: ${face.inactiveHullEdge.idString()} and ${e.idString()}.`;\n          }\n        }\n      }\n      v = e.getOtherNode(v) as CreasesNode;\n      e = v.clockwise(e) as Crease;\n      if (v == vStart && e == eStart) {\n        return null;\n      } else if (undiscoveredEdges.delete(e)) {\n        edgeQueue.add(e);\n      }\n    }\n    throw new Error(\"Caught in infinite loop while building faces.\");\n  }\n  while (edgeQueue.size > 0) {\n    const e = getAnyElement(edgeQueue);\n    edgeQueue.delete(e);\n    if (e.leftFace == null) {\n      const errorMessage = fillInFaceToTheLeft(e.from as CreasesNode, e);\n      if (errorMessage != null) {\n        return errorMessage;\n      }\n    }\n    if (e.rightFace == null) {\n      const errorMessage = fillInFaceToTheLeft(e.to as CreasesNode, e);\n      if (errorMessage != null) {\n        return errorMessage;\n      }\n    }\n  }\n\n  if (!foundOuterFace) {\n    throw new Error(\"Could not find outer face.\");\n  }\n\n  // Check that all creases are accounted for (will be good if graph is connected).\n  if (undiscoveredEdges.size > 0) {\n    throw new Error(\n      `Edges ${Array.from(undiscoveredEdges).map(e =>\n        e.idString()\n      )} lie in different component than first hull edge.`\n    );\n  }\n\n  g.state = CreasesGraphState.PreUMA;\n  return null;\n}\n\nexport function isTwisted(\n  d: Map<string, Map<string, Array<[string, number]>>>,\n  g: CreasesGraph\n) {\n  if (g.state != CreasesGraphState.PreUMA) {\n    throw new Error(\n      `Should not be calling isTwisted from state ${\n        CreasesGraphState[g.state]\n      }.`\n    );\n  }\n  for (const face of g.faces) {\n    const visitedEdgeStrings: Set<string> = new Set();\n    for (let faceIndex = 0; faceIndex < face.nodes.length; faceIndex++) {\n      const vStart = face.nodes[faceIndex] as CreasesNode;\n      const vEnd = face.nodes[\n        (faceIndex + 1) % face.nodes.length\n      ] as CreasesNode;\n      //console.log(`vStart: ${vStart.id}  vEnd: ${vEnd.id}`);\n      const distancesAlongPath = d.get(vStart.id)?.get(vEnd.id) as Array<\n        [string, number]\n      >;\n      //console.log(distancesAlongPath);\n      const numInternalEdgesToCheck = distancesAlongPath.length - 2;\n      for (\n        let pathIndex = 0;\n        pathIndex < numInternalEdgesToCheck;\n        pathIndex++\n      ) {\n        const id1: string = distancesAlongPath[pathIndex][0];\n        const id2: string = distancesAlongPath[pathIndex + 1][0];\n        const edgeString = id1 + \"-\" + id2;\n        if (visitedEdgeStrings.has(edgeString)) {\n          return true;\n        } else {\n          //console.log(edgeString);\n          visitedEdgeStrings.add(edgeString);\n        }\n      }\n    }\n  }\n  return false;\n}\n\nexport function buildMoleculeRecursive(\n  g: CreasesGraph,\n  baseFace: Face,\n  boundary: CreasesNode[],\n  z: Map<\n    CreasesNode,\n    Map<CreasesNode, Array<[string, number, CreasesNode | null]>>\n  >,\n  newCreases: Set<Crease>,\n  elevation: number\n) {\n  // Compute inset amount h. Cut-and-pasted from TM5 source code:\n  // https://github.com/6849-2020/treemaker/blob/75b47cdcd46a45e5de0eba95630119d2828426ad/Source/tmModel/tmTreeClasses/tmPoly.cpp#L719\n  const nn = boundary.length;\n  const r: number[][] = []; // bisector vector at each corner\n  const rp: number[][] = []; // normalized vector to previous corner\n  const rn: number[][] = []; // normalized vector to next corner\n  const mr: number[] = []; // magnitude of projection of r along previous side\n\n  for (let i = 0; i < nn; i++) {\n    // get offsets of previous (ip) and next (in) corner, including\n    // wrap-around effects.\n    const ip = (i + nn - 1) % nn;\n    const iN = (i + 1) % nn;\n\n    const nip = boundary[ip];\n    const nii = boundary[i];\n    const nin = boundary[iN];\n\n    // construct bisector and the magnitude of its projections along the\n    // previous and next sides. All quantities are normalized to a unit inset\n    // distance h.\n    const dxp = nip.x - nii.x;\n    const dyp = nip.y - nii.y;\n    const magnitudeP = Math.sqrt(dxp * dxp + dyp * dyp);\n    const rpx = dxp / magnitudeP;\n    const rpy = dyp / magnitudeP;\n    rp.push([rpx, rpy]); // vector to previous corner\n    const dxn = nin.x - nii.x;\n    const dyn = nin.y - nii.y;\n    const magnitudeN = Math.sqrt(dxn * dxn + dyn * dyn);\n    const rnx = dxn / magnitudeN;\n    const rny = dyn / magnitudeN;\n    rn.push([rnx, rny]); // vector to next corner\n    const dxbis = rpy - rny;\n    const dybis = rnx - rpx;\n    const magnitudeBis = Math.sqrt(dxbis * dxbis + dybis * dybis);\n    const bisx = dxbis / magnitudeBis; // angle bisector\n    const bisy = dybis / magnitudeBis; // angle bisector\n    const innerProduct = bisy * rnx - bisx * rny;\n    const rx = bisx / innerProduct;\n    const ry = bisy / innerProduct;\n    r.push([rx, ry]); // normalize to unit inset\n    mr.push(rx * rpx + ry * rpy); // cotangent of bisected angle\n  }\n\n  // Now compute the maximum value of the inset distance h that satifies the\n  // reduced path condition for every path in the polygon. We handle RingPaths\n  // and CrossPaths differently. i and j are the indices of the corners of the\n  // path.\n\n  let h = 2; // the best inset distance to use\n  for (let i = 0; i < nn; i++) {\n    for (let j = i + 1; j < nn; j++) {\n      const [rix, riy] = r[i];\n      const [rjx, rjy] = r[j];\n\n      // If the angle bisectors are parallel and are pointing the same\n      // direction, there's no solution, so go on to the next corner.\n      const riAngle = Math.atan2(riy, rix);\n      const rjAngle = Math.atan2(rjy, rjx);\n      const angleDiff = Math.abs(rjAngle - riAngle);\n      if (angleDiff < TOLERANCE || angleDiff > IS_RIGHT_TURN_CUTOFF_4) {\n        continue;\n      }\n\n      // Get coordinates of the two nodes that we're checking\n      const ni = boundary[i];\n      const nj = boundary[j];\n\n      // for paths between adjacent nodes, we'll use the intersection of\n      // the bisectors to determine the maximum inset.\n      if (j == i + 1 || (i == 0 && j == nn - 1)) {\n        const numeratorX = ni.x - nj.x;\n        const numeratorY = ni.y - nj.y;\n        const denominatorX = rjx - rix;\n        const denominatorY = rjy - riy;\n        const denominator =\n          denominatorX * denominatorX + denominatorY * denominatorY;\n        if (denominator > 0) {\n          const numerator = numeratorX * numeratorX + numeratorY * numeratorY;\n          const h1 = Math.sqrt(numerator / denominator);\n          if (h > h1) {\n            //console.log(`Updating h = ${h1} from collision.`);\n            h = h1;\n          }\n        }\n      } else {\n        // for paths between nonadjacent nodes, we'll compute the inset\n        // distance (using the cotangents of the base angles) that makes the\n        // given path active. If the computed inset distance is either complex\n        // or negative, there's no solution. We'll keep the smallest inset\n        // distance that we find.\n\n        // Note: an alternate way of structuring this would be to iterate\n        // through the mRingPaths and mCrossPaths separately; I wouldn't have\n        // to call FindPath. But I reference the tmNode information in the\n        // vectors by what amounts to the index of the mRingNode. So I do it\n        // this way. A better way, which I should implement in the future, is\n        // to put the vector data into scratch fields of the tmNode.\n\n        // Note that if the reduced path length comes out to be negative,\n        // we've found a spurious solution; so we have to detect and\n        // eliminate that case.\n        let lij = 0;\n        const zMap = z.get(ni);\n        if (zMap == undefined) {\n          const zDistances = (z.get(nj) as Map<\n            CreasesNode,\n            Array<[string, number, CreasesNode | null]>\n          >).get(ni) as Array<[string, number, CreasesNode | null]>;\n          lij = (zDistances[zDistances.length - 1] as [\n            string,\n            number,\n            CreasesNode | null\n          ])[1];\n        } else {\n          let zDistances = zMap.get(nj);\n          if (zDistances == undefined) {\n            zDistances = (z.get(nj) as Map<\n              CreasesNode,\n              Array<[string, number, CreasesNode | null]>\n            >).get(ni);\n          }\n          lij = ((zDistances as Array<[string, number, CreasesNode | null]>)[\n            (zDistances as Array<[string, number, CreasesNode | null]>).length -\n              1\n          ] as [string, number, CreasesNode | null])[1];\n        }\n        const ux = ni.x - nj.x;\n        const uy = ni.y - nj.y;\n        const vx = rix - rjx;\n        const vy = riy - rjy;\n        const w = (mr[i] as number) + (mr[j] as number);\n        const a = vx * vx + vy * vy - w * w;\n        const b = ux * vx + uy * vy + lij * w;\n        const c = ux * ux + uy * uy - lij * lij;\n        const d = b * b - a * c;\n        if (d < 0) continue; // both solutions are complex\n\n        let h1 = (-b + Math.sqrt(d)) / a; // trial solution for inset distance\n        let lijp = lij - h1 * w; // reduced path length\n        if (lijp > 0 && h1 > 0 && h > h1) {\n          //console.log(`Updating h = ${h1} from first case of active reduced path.`);\n          h = h1;\n        }\n\n        h1 = (-b - Math.sqrt(d)) / a; // other trial solution\n        lijp = lij - h1 * (mr[i] + mr[j]); // reduced path length\n        if (lijp > 0 && h1 > 0 && h > h1) {\n          //console.log(`Updating h = ${h1} from second case of active reduced path.`);\n          h = h1;\n        }\n      }\n    }\n  }\n  const newElevation = elevation + h;\n\n  // Compute locations of inset nodes and connect with Ridge creases.\n  const insetNodes: Array<CreasesNode> = [];\n  const otherRidgeNodesArray: Array<CreasesNode> = [];\n  const otherRidgeNodes = new Map<Crease, Array<[number, CreasesNode]>>();\n  function getOrMakeNode(\n    nodeX: number,\n    nodeY: number,\n    checkInsetNodes: boolean,\n    displayId: string\n  ): [CreasesNode, boolean] {\n    for (const alreadyThereNode of checkInsetNodes\n      ? insetNodes\n      : otherRidgeNodesArray) {\n      if (\n        Math.abs(alreadyThereNode.x - nodeX) < TOLERANCE &&\n        Math.abs(alreadyThereNode.y - nodeY) < TOLERANCE\n      ) {\n        if (displayId != \"\") {\n          alreadyThereNode.displayId = displayId;\n        }\n        return [alreadyThereNode, false] as [CreasesNode, boolean];\n      }\n    }\n    const newNode = new CreasesNode(\n      g.nextInternalId(),\n      displayId,\n      nodeX,\n      nodeY,\n      newElevation\n    );\n    //console.log(`Making new node from getOrMake - ${newNode.id} at (${nodeX}, ${nodeY}).`);\n    return [newNode, true] as [CreasesNode, boolean];\n  }\n  for (let i = 0; i < boundary.length; i++) {\n    const boundaryNode = boundary[i] as CreasesNode;\n    const [rix, riy] = r[i] as [number, number];\n    const insetNodeX = boundaryNode.x + h * rix;\n    const insetNodeY = boundaryNode.y + h * riy;\n    const [insetNode, madeNewNode] = getOrMakeNode(\n      insetNodeX,\n      insetNodeY,\n      true,\n      \"\"\n    );\n    if (madeNewNode) {\n      insetNodes.push(insetNode);\n      g.addNode(insetNode);\n    }\n    boundaryNode.goUpRidge = insetNode;\n    const newCrease = new Crease(\n      insetNode,\n      boundaryNode,\n      CreaseType.Ridge,\n      baseFace\n    );\n    otherRidgeNodes.set(newCrease, []);\n    newCreases.add(newCrease);\n    g.addEdge(newCrease);\n  }\n\n  // Hook up hinge creases and use to define z on adjacent inset nodes.\n  //console.log(`Inset nodes: ${insetNodes.map(n => n.id)}`);\n  const numberOfInsetNodes = insetNodes.length;\n  let finalRidgeCreaseNode1: CreasesNode | null = null;\n  let finalRidgeCreaseNode2: CreasesNode | null = null;\n  if (insetNodes.length == 2) {\n    [finalRidgeCreaseNode1, finalRidgeCreaseNode2] = insetNodes;\n  }\n\n  for (let i = 0; i < nn; i++) {\n    for (let j = i + 1; j < nn; j++) {\n      let chopOffFromJ = h * mr[j];\n      let chopOffFromI = h * mr[i];\n      let nodeJ = boundary[j];\n      let nodeI = boundary[i];\n      if (\n        z.get(nodeJ) == undefined ||\n        (z.get(nodeJ) as Map<\n          CreasesNode,\n          Array<[string, number, CreasesNode | null]>\n        >).get(nodeI) == undefined\n      ) {\n        // The zDistances are only defined in one (arbitrary) direction, so need to swap everything if we guessed wrong.\n        const temp1 = nodeJ;\n        nodeJ = nodeI;\n        nodeI = temp1;\n        const temp2 = chopOffFromJ;\n        chopOffFromJ = chopOffFromI;\n        chopOffFromI = temp2;\n      }\n      const insetNodeJ = nodeJ.goUpRidge as CreasesNode;\n      const insetNodeI = nodeI.goUpRidge as CreasesNode;\n      const adjacentOnBoundary = j == i + 1 || (i == 0 && j == nn - 1);\n      if (!adjacentOnBoundary) {\n        if (insetNodeI == insetNodeJ) {\n          continue;\n        }\n        const index = insetNodes.indexOf(insetNodeJ);\n        const nextIndex = (index + 1) % numberOfInsetNodes;\n        const previousIndex =\n          (index + numberOfInsetNodes - 1) % numberOfInsetNodes;\n        if (\n          insetNodes[previousIndex] == insetNodeI ||\n          insetNodes[nextIndex] == insetNodeI\n        ) {\n          continue;\n        }\n      }\n      const zDistances = (z.get(nodeJ) as Map<\n        CreasesNode,\n        Array<[string, number, CreasesNode]>\n      >).get(nodeI) as Array<[string, number, CreasesNode]>;\n      const distanceToI = (zDistances[zDistances.length - 1] as [\n        string,\n        number,\n        CreasesNode | null\n      ])[1];\n      const distanceFromIToInsetJ = distanceToI - chopOffFromJ;\n      const insetDistanceToI = distanceFromIToInsetJ - chopOffFromI;\n      const insetZDistances: Array<[string, number, CreasesNode | null]> = [];\n      if (z.get(insetNodeJ) == undefined) {\n        z.set(insetNodeJ, new Map());\n      }\n      (z.get(insetNodeJ) as Map<\n        CreasesNode,\n        Array<[string, number, CreasesNode | null]>\n      >).set(insetNodeI, insetZDistances);\n      const numInternalNodes = zDistances.length - 1;\n      let lastNode = insetNodeJ;\n      for (let k = 0; k < numInternalNodes; k++) {\n        const [\n          internalNodeId,\n          distanceToInternalNode,\n          internalNode\n        ] = zDistances[k];\n        if (adjacentOnBoundary && internalNode == null) {\n          throw new Error(\n            `Null internal node between ${nodeJ.id} and ${nodeI.id} at distance ${distanceToInternalNode}.`\n          );\n        }\n        const insetDistanceToInternalNode =\n          distanceToInternalNode - chopOffFromJ;\n        if (insetDistanceToInternalNode < -TOLERANCE) {\n          // Hinge crease intersects ridge crease to j.\n          if (adjacentOnBoundary) {\n            const fractionOver = distanceToInternalNode / chopOffFromJ;\n            const [hingeNodeOnJRidge, madeNewNode] = getOrMakeNode(\n              (1 - fractionOver) * nodeJ.x + fractionOver * insetNodeJ.x,\n              (1 - fractionOver) * nodeJ.y + fractionOver * insetNodeJ.y,\n              false,\n              internalNodeId\n            );\n            if (madeNewNode) {\n              g.addNode(hingeNodeOnJRidge);\n              otherRidgeNodesArray.push(hingeNodeOnJRidge);\n              (otherRidgeNodes.get(\n                g.getEdge(nodeJ, insetNodeJ) as Crease\n              ) as Array<[number, CreasesNode]>).push([\n                distanceToInternalNode,\n                hingeNodeOnJRidge\n              ]);\n            }\n            const newCrease = new Crease(\n              hingeNodeOnJRidge,\n              internalNode,\n              CreaseType.Hinge,\n              baseFace\n            );\n            newCreases.add(newCrease);\n            g.addEdge(newCrease);\n          }\n        } else if (insetDistanceToInternalNode < TOLERANCE) {\n          // Hinge crease intersects ridge vertex j exactly.\n          if (adjacentOnBoundary) {\n            insetNodeJ.displayId = internalNodeId;\n            const newCrease = new Crease(\n              insetNodeJ,\n              internalNode,\n              CreaseType.Hinge,\n              baseFace\n            );\n            newCreases.add(newCrease);\n            g.addEdge(newCrease);\n          }\n        } else if (insetDistanceToInternalNode < insetDistanceToI - TOLERANCE) {\n          // Hinge crease intersects in the middle, need to add to z.\n          if (adjacentOnBoundary) {\n            const fractionOver = insetDistanceToInternalNode / insetDistanceToI;\n            const [hingeNodeOnInsetBoundary, madeNewNode] = getOrMakeNode(\n              (1 - fractionOver) * insetNodeJ.x + fractionOver * insetNodeI.x,\n              (1 - fractionOver) * insetNodeJ.y + fractionOver * insetNodeI.y,\n              false,\n              internalNodeId\n            );\n            if (madeNewNode) {\n              g.addNode(hingeNodeOnInsetBoundary);\n              otherRidgeNodesArray.push(hingeNodeOnInsetBoundary);\n              insetZDistances.push([\n                hingeNodeOnInsetBoundary.displayId,\n                insetDistanceToInternalNode,\n                hingeNodeOnInsetBoundary\n              ]);\n              if (numberOfInsetNodes == 2) {\n                const newCrease = new Crease(\n                  hingeNodeOnInsetBoundary,\n                  lastNode,\n                  CreaseType.Ridge,\n                  baseFace\n                );\n                newCreases.add(newCrease);\n                g.addEdge(newCrease);\n                lastNode = hingeNodeOnInsetBoundary;\n                finalRidgeCreaseNode1 = lastNode;\n                finalRidgeCreaseNode2 = insetNodeI;\n              }\n            }\n            const newCrease = new Crease(\n              hingeNodeOnInsetBoundary,\n              internalNode,\n              CreaseType.Hinge,\n              baseFace\n            );\n            newCreases.add(newCrease);\n            g.addEdge(newCrease);\n          } else {\n            insetZDistances.push([\n              internalNodeId,\n              insetDistanceToInternalNode,\n              null\n            ]);\n          }\n        } else if (insetDistanceToInternalNode < insetDistanceToI + TOLERANCE) {\n          // Hinge crease intersects ridge vertex i exactly.\n          insetNodeI.displayId = internalNodeId;\n          if (adjacentOnBoundary) {\n            const newCrease = new Crease(\n              insetNodeI,\n              internalNode,\n              CreaseType.Hinge,\n              baseFace\n            );\n            newCreases.add(newCrease);\n            g.addEdge(newCrease);\n          }\n        } else if (\n          insetDistanceToInternalNode <\n          distanceFromIToInsetJ - TOLERANCE\n        ) {\n          // Hinge crease intersects ridge crease to i.\n          if (adjacentOnBoundary) {\n            const distanceFromEnd =\n              distanceFromIToInsetJ - insetDistanceToInternalNode;\n            const fractionOver = distanceFromEnd / chopOffFromI;\n            const [hingeNodeOnIRidge, madeNewNode] = getOrMakeNode(\n              (1 - fractionOver) * nodeI.x + fractionOver * insetNodeI.x,\n              (1 - fractionOver) * nodeI.y + fractionOver * insetNodeI.y,\n              false,\n              internalNodeId\n            );\n            if (madeNewNode) {\n              g.addNode(hingeNodeOnIRidge);\n              otherRidgeNodesArray.push(hingeNodeOnIRidge);\n              (otherRidgeNodes.get(\n                g.getEdge(nodeI, insetNodeI) as Crease\n              ) as Array<[number, CreasesNode]>).push([\n                distanceFromEnd,\n                hingeNodeOnIRidge\n              ]);\n            }\n            const newCrease = new Crease(\n              hingeNodeOnIRidge,\n              internalNode,\n              CreaseType.Hinge,\n              baseFace\n            );\n            newCreases.add(newCrease);\n            g.addEdge(newCrease);\n          }\n        } else {\n          throw new Error(\n            `Distance from ${nodeJ.id} to ${internalNode.id} along boundary path to ${nodeI.id} is ${distanceToInternalNode}, which is too large (should be less than ${distanceFromIToInsetJ}).`\n          );\n        }\n      }\n      insetZDistances.push([\n        insetNodeI.displayId,\n        insetDistanceToI,\n        insetNodeI\n      ]);\n    }\n  }\n  if (finalRidgeCreaseNode1 != null) {\n    // This only happens if there are exactly two inset nodes - the rest of the ridge creases were filled in as the hinge nodes were added.\n    const newCrease = new Crease(\n      finalRidgeCreaseNode2 as CreasesNode,\n      finalRidgeCreaseNode1 as CreasesNode,\n      CreaseType.Ridge,\n      baseFace\n    );\n    newCreases.add(newCrease);\n    g.addEdge(newCrease);\n  }\n\n  // Subdivide ridges with new points that have been inserted for hinges creases.\n  for (const ridgeCrease of otherRidgeNodes.keys()) {\n    const nodesAlongRidge = otherRidgeNodes.get(ridgeCrease) as Array<\n      [number, CreasesNode]\n    >;\n    if (nodesAlongRidge.length > 0) {\n      nodesAlongRidge.sort((x, y) => x[0] - y[0]);\n      newCreases.delete(ridgeCrease);\n      g.removeEdge(ridgeCrease);\n      let lastNode = ridgeCrease.from as CreasesNode;\n      for (const nextNode of nodesAlongRidge\n        .map(x => x[1] as CreasesNode)\n        .concat(ridgeCrease.to as CreasesNode)) {\n        const newCrease = new Crease(\n          lastNode,\n          nextNode,\n          CreaseType.Ridge,\n          baseFace\n        );\n        newCreases.add(newCrease);\n        g.addEdge(newCrease);\n        lastNode = nextNode;\n      }\n    }\n  }\n\n  // Recursively build sub-molecules if necessary.\n  if (numberOfInsetNodes > 2) {\n    //console.log(`Beginning recursive subdivision on inset nodes ${insetNodes.map(n => n.id)}.`);\n    const indexStack = [numberOfInsetNodes - 1, 0];\n    for (let numIterations = 0; numIterations < 100; numIterations++) {\n      if (indexStack.length == 0) {\n        //console.log(`Ending recursive subdivision on ${insetNodes.map(n => n.id)}.`);\n        return newCreases;\n      } else {\n        const newBoundaryStartIndex = indexStack.pop() as number;\n        const newBoundaryEndIndex = indexStack.pop() as number;\n        ///console.log(`NEW ITERATION on ${insetNodes.map(n => n.id)} - Start index: ${newBoundaryStartIndex}  End index: ${newBoundaryEndIndex}.`);\n        const newBoundary = [insetNodes[newBoundaryStartIndex]];\n        let activePathStartIndex = newBoundaryStartIndex;\n        while (activePathStartIndex < newBoundaryEndIndex) {\n          let activePathEndIndex =\n            activePathStartIndex == newBoundaryStartIndex\n              ? newBoundaryEndIndex - 1\n              : newBoundaryEndIndex;\n          //console.log(`Starting to look for active reduced paths from start index ${activePathStartIndex} to end index ${activePathEndIndex}.`);\n          for (\n            ;\n            activePathEndIndex > activePathStartIndex + 1;\n            activePathEndIndex--\n          ) {\n            let activePathStartNode = insetNodes[activePathStartIndex];\n            let activePathEndNode = insetNodes[activePathEndIndex];\n            //console.log(`Checking if there is an active reduced path between ${activePathStartNode.id} and ${activePathEndNode.id}.`);\n            if (\n              z.get(activePathStartNode) == undefined ||\n              (z.get(activePathStartNode) as Map<\n                CreasesNode,\n                Array<[string, number, CreasesNode | null]>\n              >).get(activePathEndNode) == undefined\n            ) {\n              const temp = activePathStartNode;\n              activePathStartNode = activePathEndNode;\n              activePathEndNode = temp;\n            }\n            const zDistances = (z.get(activePathStartNode) as Map<\n              CreasesNode,\n              Array<[string, number, CreasesNode | null]>\n            >).get(activePathEndNode) as Array<\n              [string, number, CreasesNode | null]\n            >;\n            const distanceFromStartToEnd = (zDistances[\n              zDistances.length - 1\n            ] as [string, number, CreasesNode | null])[1];\n            const dx = activePathEndNode.x - activePathStartNode.x;\n            const dy = activePathEndNode.y - activePathStartNode.y;\n            const distanceDifference =\n              Math.sqrt(dx * dx + dy * dy) - distanceFromStartToEnd;\n            if (distanceDifference < TOLERANCE) {\n              // Active reduced path, so fill in zDistances with new nodes, connected by Gusset creases.\n              //console.log(\"There is.\");\n              if (distanceDifference < -TOLERANCE) {\n                console.log(zDistances);\n                console.log(distanceFromStartToEnd);\n                console.log(Math.sqrt(dx * dx + dy * dy));\n                throw new Error(\n                  `Looks like h = ${h} was inset too much, violating distance constraint.`\n                );\n              }\n              const numInternalNodes = zDistances.length - 1;\n              let lastNode = activePathStartNode;\n              for (let k = 0; k < numInternalNodes; k++) {\n                const [\n                  internalNodeId,\n                  distanceToInternalNode,\n                  nullNode\n                ] = zDistances[k];\n                const fractionOver =\n                  distanceToInternalNode / distanceFromStartToEnd;\n                const nextNode = new CreasesNode(\n                  g.nextInternalId(),\n                  internalNodeId,\n                  (1 - fractionOver) * activePathStartNode.x +\n                    fractionOver * activePathEndNode.x,\n                  (1 - fractionOver) * activePathStartNode.y +\n                    fractionOver * activePathEndNode.y,\n                  newElevation\n                );\n                //console.log(`Making new gusset node directly - ${nextNode.id} at (${nextNode.x}, ${nextNode.y}).`);\n                g.addNode(nextNode);\n                zDistances[k][2] = nextNode;\n                const newCrease = new Crease(\n                  lastNode,\n                  nextNode,\n                  CreaseType.Gusset,\n                  baseFace\n                );\n                newCreases.add(newCrease);\n                g.addEdge(newCrease);\n                lastNode = nextNode;\n              }\n              const newCrease = new Crease(\n                activePathEndNode,\n                lastNode,\n                CreaseType.Gusset,\n                baseFace\n              );\n              newCreases.add(newCrease);\n              g.addEdge(newCrease);\n              indexStack.push(activePathEndIndex);\n              indexStack.push(activePathStartIndex);\n              break;\n            }\n          }\n          //console.log(`Adding ${(insetNodes[activePathEndIndex] as Node).id} to newBoundary.`);\n          newBoundary.push(insetNodes[activePathEndIndex]);\n          activePathStartIndex = activePathEndIndex;\n        }\n        //console.log(`Making recursive call on ${newBoundary.map(n => n.id)}.`);\n        buildMoleculeRecursive(\n          g,\n          baseFace,\n          newBoundary,\n          z,\n          newCreases,\n          newElevation\n        );\n      }\n    }\n    throw new Error(\n      \"Caught in infinite loop while recursively building molecules.\"\n    );\n  }\n}\n\n// Defines z map from d and scale factor, subdividing creases for internal nodes as needed.\nexport function subdivideCreasesInitial(\n  g: CreasesGraph,\n  d: Map<string, Map<string, Array<[string, number]>>>,\n  scaleFactor: number,\n  discreteDepth: Map<string, number>\n): [\n  Map<\n    CreasesNode,\n    Map<CreasesNode, Array<[string, number, CreasesNode | null]>>\n  >,\n  Set<Crease>\n] {\n  const nodeList = Array.from(g.nodes.values());\n  const nn = nodeList.length;\n  const z: Map<\n    CreasesNode,\n    Map<CreasesNode, Array<[string, number, CreasesNode | null]>>\n  > = new Map();\n  const inactiveHullCreases: Set<Crease> = new Set();\n  for (let i = 0; i < nn; i++) {\n    const nodeI = nodeList[i] as CreasesNode;\n    const dMap = d.get(nodeI.id) as Map<string, Array<[string, number]>>;\n    const zDistanceMap: Map<\n      CreasesNode,\n      Array<[string, number, CreasesNode | null]>\n    > = new Map();\n    z.set(nodeI, zDistanceMap);\n    for (let j = i + 1; j < nn; j++) {\n      const nodeJ = nodeList[j] as CreasesNode;\n      let crease = g.getEdge(nodeI, nodeJ);\n      const distances = dMap.get(nodeJ.id) as Array<[string, number]>;\n      const zDistances: Array<[string, number, CreasesNode | null]> = [];\n      zDistanceMap.set(nodeJ, zDistances);\n      const numInternalNodes = distances.length - 1;\n      const totalDistance =\n        (distances[numInternalNodes][1] as number) +\n        (g.leafExtensions.get(nodeI) as number) +\n        (g.leafExtensions.get(nodeJ) as number);\n      if (crease != undefined && crease.creaseType == CreaseType.InactiveHull) {\n        inactiveHullCreases.add(crease);\n      } else {\n        for (let k = 0; k < numInternalNodes; k++) {\n          const [\n            internalNodeId,\n            distanceToInternalNodeWithoutLeafExtension\n          ] = distances[k] as [string, number];\n          const distanceToInternalNode =\n            distanceToInternalNodeWithoutLeafExtension +\n            (g.leafExtensions.get(nodeI) as number);\n          if (crease != undefined) {\n            // See if we need to update the local root.\n            const newDepth = discreteDepth.get(internalNodeId);\n            if (newDepth == undefined) {\n              console.log(discreteDepth);\n              throw new Error(\n                `Undefined (${newDepth}) new discrete depth for local root '${internalNodeId}'.`\n              );\n            }\n            for (const baseFace of [\n              crease.leftFace,\n              crease.rightFace\n            ] as Face[]) {\n              const oldDepth = discreteDepth.get(\n                baseFace.baseFaceLocalRoot as string\n              );\n              if (oldDepth == undefined) {\n                console.log(discreteDepth);\n                throw new Error(\n                  `Undefined prior discrete depth for local root '${baseFace.baseFaceLocalRoot}'.`\n                );\n              }\n              if (newDepth < oldDepth) {\n                baseFace.baseFaceLocalRoot = internalNodeId;\n              }\n            }\n\n            const fractionOver = distanceToInternalNode / totalDistance;\n            const creaseFrom = crease.from;\n            const creaseTo = crease.to;\n            const newNode = g.subdivideCrease(\n              crease,\n              (1 - fractionOver) * nodeI.x + fractionOver * nodeJ.x,\n              (1 - fractionOver) * nodeI.y + fractionOver * nodeJ.y,\n              internalNodeId,\n              0\n            );\n            crease = g.getEdge(newNode, nodeJ) as Crease;\n            if (crease == undefined) {\n              // Active path, so zDistances stores actual nodes.\n              throw new Error(\n                `Cannot find next crease after subdividing between ${creaseFrom.id} and ${creaseTo.id} with new node corresponding to ${internalNodeId} at (${newNode.x}, ${newNode.y}).`\n              );\n            }\n            zDistances.push([\n              newNode.displayId,\n              distanceToInternalNode * scaleFactor,\n              newNode\n            ]);\n          } else {\n            // Not an active path, so no nodes yet, but we'll need to keep track of distances in case it becomes an active reduced path later.\n            zDistances.push([\n              internalNodeId,\n              distanceToInternalNode * scaleFactor,\n              null\n            ]);\n          }\n        }\n      }\n      zDistances.push([nodeJ.id, totalDistance * scaleFactor, nodeJ]);\n    }\n  }\n  return [z, inactiveHullCreases] as [\n    Map<\n      CreasesNode,\n      Map<CreasesNode, Array<[string, number, CreasesNode | null]>>\n    >,\n    Set<Crease>\n  ];\n}\n\nexport function generateMolecules(\n  g: CreasesGraph,\n  d: Map<string, Map<string, Array<[string, number]>>>,\n  scaleFactor: number,\n  discreteDepth: Map<string, number>\n) {\n  if (g.state != CreasesGraphState.PreUMA) {\n    throw new Error(\n      `Should not be calling generateMolecules from state ${\n        CreasesGraphState[g.state]\n      }.`\n    );\n  }\n\n  // Record the active polygons before more nodes get added in subdivision.\n  const boundaries: Array<[Face, Array<CreasesNode>]> = [];\n  let outerFace: Face | null = null;\n  for (const face of Array.from(g.faces)) {\n    if (face.isOuterFace) {\n      outerFace = face;\n    } else {\n      boundaries.push([face, Array.from(face.nodes)]);\n    }\n  }\n  if (outerFace == null) {\n    throw new Error(\"Could not find outer face.\");\n  }\n\n  // Build molecules recursively.\n  const [z, inactiveHullCreases] = subdivideCreasesInitial(\n    g,\n    d,\n    scaleFactor,\n    discreteDepth\n  );\n  const newCreases: Set<Crease> = new Set();\n  for (const [baseFace, boundary] of boundaries) {\n    buildMoleculeRecursive(g, baseFace, boundary, z, newCreases, 0);\n  }\n\n  // Get rid of degree 2 ridge/hinge vertices.\n  for (const v of Array.from(g.nodes.values())) {\n    g.suppressNodeIfRedundant(v, newCreases);\n  }\n\n  // Fill in hinges and pseudohinges in each inactive hull face.\n  for (const inactiveHullCrease of inactiveHullCreases) {\n    const orientation = (inactiveHullCrease.rightFace as Face).isOuterFace;\n    const endNode = orientation\n      ? (inactiveHullCrease.from as CreasesNode)\n      : (inactiveHullCrease.to as CreasesNode);\n    let currentNode = orientation\n      ? (inactiveHullCrease.to as CreasesNode)\n      : (inactiveHullCrease.from as CreasesNode);\n    let currentCrease = inactiveHullCrease;\n\n    // Projection of point to line segment based on:\n    // https://stackoverflow.com/a/21055661/14766845\n    const x1 = currentNode.x;\n    const y1 = currentNode.y;\n    const x2 = endNode.x;\n    const y2 = endNode.y;\n    let dx = x2 - x1;\n    let dy = y2 - y1;\n    const mag = Math.sqrt(dx * dx + dy * dy);\n    dx /= mag;\n    currentCrease = currentNode.clockwise(currentCrease) as Crease;\n    currentNode = currentCrease.getOtherNode(currentNode) as CreasesNode;\n    const ridgeline: CreasesNode[] = [];\n    for (let numIterations = 0; numIterations < 200; numIterations++) {\n      if (currentNode == endNode) {\n        break;\n      }\n      ridgeline.push(currentNode);\n\n      currentCrease = currentNode.clockwise(currentCrease) as Crease;\n      currentNode = currentCrease.getOtherNode(currentNode) as CreasesNode;\n    }\n    if (currentNode != endNode) {\n      throw new Error(\n        \"Caught in infinite loop while filling in inactive hull face.\"\n      );\n    }\n    let baseCrease = inactiveHullCrease;\n    const baseFace = baseCrease.getOtherFace(outerFace);\n    dy /= mag;\n    for (const n of ridgeline) {\n      if (n.edges.length % 2 == 1) {\n        // Need a new crease by Maekawa's theorem.\n        let creaseType = CreaseType.Pseudohinge;\n        for (const creaseAttachedToRidgeVertex of n.edges) {\n          if (creaseAttachedToRidgeVertex.creaseType == CreaseType.Hinge) {\n            creaseType = CreaseType.Hinge;\n            break;\n          }\n        }\n        if (creaseType == CreaseType.Pseudohinge) {\n          n.hasPseudohinge = true;\n        }\n        const lambda = dx * (n.x - x1) + dy * (n.y - y1);\n        const x = dx * lambda + x1;\n        const y = dy * lambda + y1;\n\n        const newNode = g.subdivideCrease(baseCrease, x, y, n.displayId, 0);\n        baseCrease = g.getEdge(endNode, newNode) as Crease;\n        const newCrease = new Crease(n, newNode, creaseType, baseFace);\n        g.addEdge(newCrease);\n      }\n    }\n  }\n  g.state = CreasesGraphState.PostUMA;\n\n  // Fill in new faces and prep for facet ordering.\n  g.rebuildFaces(outerFace, newCreases);\n\n  g.state = CreasesGraphState.PreFacetOrdering;\n  return discreteDepth;\n}\n","import {\n  TOLERANCE,\n  BINARY_SEARCH_TOLERANCE,\n  UPDATE_TOLERANCE,\n  IS_RIGHT_TURN_CUTOFF_1,\n  IS_RIGHT_TURN_CUTOFF_2,\n  IS_RIGHT_TURN_CUTOFF_3,\n  IS_RIGHT_TURN_CUTOFF_4,\n  getAnyElement,\n  Node,\n  Edge,\n  Face,\n  TreeNode,\n  TreeEdge,\n  PackingNode,\n  Packing,\n  CreasesNode,\n  CreaseType,\n  MVAssignment,\n  Crease,\n  FacetOrderingGraph,\n  Graph,\n  TreeGraph,\n  CreasesGraphState,\n  CreasesGraph\n} from \"../packing\";\n\nfunction getMVAssignment(f1, f2, coloring) {\n  if (f1.facetOrderIndex < f2.facetOrderIndex) {\n    if (coloring) {\n      return MVAssignment.Mountain;\n    } else {\n      return MVAssignment.Valley;\n    }\n  } else if (f1.facetOrderIndex > f2.facetOrderIndex) {\n    if (coloring) {\n      return MVAssignment.Valley;\n    } else {\n      return MVAssignment.Mountain;\n    }\n  } else {\n    throw new Error(\n      `Two faces have the same facetOrderIndex: ${f1.facetOrderIndex}.`\n    );\n  }\n}\n\n// Performs a DFS on the dual graph to assign all creases and check for inconsistencies.\nfunction computeMVAssignmentRecursive(\n  g: CreasesGraph,\n  face: Face,\n  coloring: boolean\n) {\n  if (face.isColored) {\n    if (face.coloring != coloring) {\n      throw new Error(\n        `Coloring inconsistency on face ${face.nodes.map(n => n.id)}.`\n      );\n    }\n  } else {\n    //console.log(`${face.nodes.map(n => n.id)} - ${coloring}`);\n    face.isColored = true;\n    face.coloring = coloring;\n    let v1 = face.nodes[face.nodes.length - 1];\n    for (const v2 of face.nodes) {\n      const e = g.getEdge(v1, v2) as Crease;\n      const otherFace = e.getOtherFace(face);\n      if (!otherFace.isOuterFace) {\n        if (e.assignment == MVAssignment.Unfolded) {\n          computeMVAssignmentRecursive(g, otherFace, coloring);\n        } else {\n          const correctAssignment = getMVAssignment(face, otherFace, coloring);\n          if (e.assignment == MVAssignment.Unknown) {\n            e.assignment = correctAssignment;\n          } else if (e.assignment != correctAssignment) {\n            throw new Error(\n              `Inconsistency between faces ${face.nodes.map(\n                n => n.id\n              )} and ${otherFace.nodes.map(\n                n => n.id\n              )}: crease ${e.idString()} [from node ${e.from.displayId} at (${\n                e.from.x\n              }, ${e.from.y}) to node ${e.to.displayId} at (${e.to.x}, ${\n                e.to.y\n              })] should be assigned ${\n                MVAssignment[correctAssignment]\n              } but is actually assigned ${MVAssignment[e.assignment]}.`\n            );\n          }\n          computeMVAssignmentRecursive(g, otherFace, !coloring);\n        }\n      }\n      v1 = v2;\n    }\n  }\n}\n\nfunction findNextNonPseudohingeFacet(f: Face) {\n  for (let numIterations = 0; numIterations < 100; numIterations++) {\n    if (!f.extendedHasPseudohinge) {\n      return f;\n    }\n    f = (f.creaseToNextAxialFacet as Crease).getOtherFace(f);\n  }\n  throw new Error(\n    \"Caught in infinite loop while trying to find a non-pseudohinge-facet.\"\n  );\n}\n\nfunction isValidMOGMergePoint(axialFacet1: Face) {\n  const hinge1 = axialFacet1.creaseToNextAxialFacet as Crease;\n  if (hinge1.creaseType != CreaseType.Hinge) {\n    return false;\n  }\n  const nextAxialFacet1 = hinge1.getOtherFace(axialFacet1);\n  const axialFacet2 = nextAxialFacet1.crossAxialOrHull as Face;\n  if (axialFacet2.isOuterFace) {\n    throw new Error(\n      `Tried to merge MOGs across from outer face ${axialFacet2.nodes.map(\n        n => n.id\n      )}, which should have been caught earlier.`\n    );\n  }\n  const hinge2 = axialFacet2.creaseToNextAxialFacet as Crease;\n  if (hinge2.creaseType != CreaseType.Hinge) {\n    throw new Error(\n      `Tried to merge MOGs across from face ${axialFacet2.nodes.map(\n        n => n.id\n      )}, which is not immediately before a hinge.`\n    );\n  }\n  const hingeNodeId = hinge1.from.displayId;\n  if (hingeNodeId != hinge2.from.displayId) {\n    throw new Error(\n      `Hinge displayId mismatch: hinge ${hinge1.idString()} has displayId ${\n        hinge1.from.displayId\n      }, but hinge ${hinge2.idString()} has displayId ${hinge2.from.displayId}`\n    );\n  }\n  const baseFace2 = axialFacet2.baseFaceLocalRoot as Face;\n  return baseFace2.baseFaceLocalRoot == hingeNodeId;\n}\n\n// Sets hinge creases to be unfolded if discrete depth difference is 2.\nfunction assignUnfoldedHinges(\n  g: CreasesGraph,\n  discreteDepth: Map<string, number>\n): Face {\n  let globalSourceBaseFace: Face | null = null;\n  for (const crease of g.edges.values()) {\n    if (crease.creaseType == CreaseType.Hinge) {\n      const leftFlap = (crease.leftFace as Face).flap;\n      const rightFlap = (crease.rightFace as Face).flap;\n      let leftId = \"unset\";\n      let rightId = \"unset\";\n      let intersectingId = \"unset\";\n      for (const s of leftFlap) {\n        if (rightFlap.has(s)) {\n          intersectingId = s;\n        } else {\n          leftId = s;\n        }\n      }\n      for (const s of rightFlap) {\n        if (!leftFlap.has(s)) {\n          rightId = s;\n          break;\n        }\n      }\n      if (\n        leftId == \"unset\" ||\n        rightId == \"unset\" ||\n        intersectingId == \"unset\"\n      ) {\n        throw new Error(\n          `Flaps do not intersect properly at hinge ${crease.idString()}: leftFlap=${Array.from(\n            leftFlap\n          )}, rightFlap=${Array.from(rightFlap)}.`\n        );\n      }\n      if (\n        !(\n          intersectingId == crease.from.displayId &&\n          intersectingId == crease.to.displayId\n        )\n      ) {\n        throw new Error(\n          `Inconsistency among hinge/flap ids at hinge ${crease.idString()}: intersectingId=${intersectingId}, from=${\n            crease.from.displayId\n          }, to=${crease.to.displayId}.`\n        );\n      }\n      const leftDepth = discreteDepth.get(leftId) as number;\n      const rightDepth = discreteDepth.get(rightId) as number;\n      const depthDifference = Math.abs(leftDepth - rightDepth);\n      if (depthDifference == 0) {\n        // Folded, do nothing.\n      } else if (depthDifference == 2) {\n        crease.assignment = MVAssignment.Unfolded;\n      } else {\n        throw new Error(\n          `Invalid discrete depth difference hinge ${crease.idString()}: node ${leftId} has depth ${leftDepth}, and node ${rightId} has depth ${rightDepth}.`\n        );\n      }\n\n      // See if the face to the right of the hinge can be the source for an MOG.\n      const baseFace = crease.baseFace as Face;\n      if (baseFace.moleculeSource == null && crease.from.elevation == 0) {\n        const potentialMoleculeSource = crease.rightFace as Face;\n        if (!potentialMoleculeSource.hasPseudohinge) {\n          const localRoot = baseFace.baseFaceLocalRoot as string;\n          if (crease.from.displayId == localRoot) {\n            baseFace.moleculeSource = potentialMoleculeSource;\n            if (\n              globalSourceBaseFace == null &&\n              discreteDepth.get(intersectingId) == 0\n            ) {\n              globalSourceBaseFace = baseFace;\n            }\n          }\n        }\n      }\n    }\n  }\n  if (globalSourceBaseFace == null) {\n    throw new Error(\"Could not find global root hinge.\");\n  } else {\n    return globalSourceBaseFace; // Assuming hinges point inward in each molecule.\n  }\n}\n\n// Sets Face fields extendedHasPseudohinge and creaseToPreviousAxialFacet.\nfunction annotateExtendedPseudohinges(sourceFace: Face) {\n  let currentFace = sourceFace;\n  let possibleExtendedPseudohinges: Face[] = [];\n  let foundPseudohinge = false;\n  for (let numIterations = 0; numIterations < 200; numIterations++) {\n    possibleExtendedPseudohinges.push(currentFace);\n    const nextCrease = currentFace.creaseToNextAxialFacet as Crease;\n    if (currentFace.hasPseudohinge) {\n      foundPseudohinge = true;\n    }\n    if (nextCrease.assignment != MVAssignment.Unfolded) {\n      if (foundPseudohinge) {\n        for (const f of possibleExtendedPseudohinges) {\n          f.extendedHasPseudohinge = true;\n        }\n      }\n      possibleExtendedPseudohinges = [];\n      foundPseudohinge = false;\n    }\n    const nextFace = nextCrease.getOtherFace(currentFace) as Face;\n    nextFace.creaseToPreviousAxialFacet = nextCrease;\n    if (nextFace == sourceFace) {\n      return;\n    } else {\n      currentFace = nextFace;\n    }\n  }\n  throw new Error(\n    \"Caught in infinite loop while annotating extended pseudohinges.\"\n  );\n}\n\nfunction launchPseudohingeCorridors(\n  orderingGraph: FacetOrderingGraph,\n  currentFace: Face,\n  isOrdinaryDirection: boolean\n) {\n  for (let numIterations = 0; numIterations < 100; numIterations++) {\n    const nextCrease = (isOrdinaryDirection\n      ? currentFace.creaseToNextAxialFacet\n      : currentFace.creaseToPreviousAxialFacet) as Crease;\n    const nextFace = nextCrease.getOtherFace(currentFace) as Face;\n    if (\n      nextCrease.assignment != MVAssignment.Unfolded ||\n      nextFace.hasPseudohinge\n    ) {\n      return;\n    }\n    orderingGraph.addFace(nextFace);\n    orderingGraph.addEdge(currentFace, nextFace);\n    currentFace = nextFace;\n    const corridor = currentFace.corridor as Face[];\n    const nextFaceInCorridor = corridor[1] as Face;\n    if (orderingGraph.faces.has(nextFaceInCorridor)) {\n      /* Turns out this can actually happen and it's not an error see decodedBadCorridorAfterPseudohinge.\n      throw new Error(\n        `Already encountered corridor chain going the other direction from face ${currentFace.nodes.map(\n          n => n.id\n        )}, but attempted to launch a new corridor after crossing a pseudohinge.`\n      );*/\n      continue;\n    }\n    const numVerticesInCorridor = corridor.length;\n    //console.log(`Found corridor (after crossing pseudohinge) of length ${numVerticesInCorridor}:`);\n    //console.log(corridor.map(f => f.nodes.map(n => n.id)));\n    let lastCorridorFace = currentFace;\n    for (let i = 1; i < numVerticesInCorridor; i++) {\n      const corridorFace = corridor[i] as Face;\n      if (orderingGraph.faces.has(corridorFace)) {\n        throw new Error(\n          `Corridor (after pseudohinge) face ${corridorFace.nodes.map(\n            n => n.id\n          )} was already visited.`\n        );\n      }\n      orderingGraph.addFace(corridorFace);\n      orderingGraph.addEdge(lastCorridorFace, corridorFace);\n      lastCorridorFace = corridorFace;\n    }\n  }\n  throw new Error(\n    \"Caught in infinite loop while annotating extended pseudohinges.\"\n  );\n}\n\nfunction buildROGRecursive(\n  orderingGraph: FacetOrderingGraph,\n  visitedMolecules: Set<Face>,\n  baseFace: Face,\n  mergePoint: Face | null,\n  globalSourceFace: Face\n) {\n  visitedMolecules.add(baseFace);\n  const sourceFace = baseFace.moleculeSource as Face;\n  orderingGraph.addFace(sourceFace);\n  annotateExtendedPseudohinges(sourceFace);\n\n  // Main loop to construct MOG.\n  let currentFace = findNextNonPseudohingeFacet(sourceFace);\n  for (let numIterations = 0; numIterations < 200; numIterations++) {\n    //console.log(currentFace.nodes.map(n => n.id));\n    // Launch corridor chain if haven't done so already from the other direction.\n    const corridor = currentFace.corridor as Face[];\n    const nextFaceInCorridor = corridor[1] as Face;\n    if (!orderingGraph.faces.has(nextFaceInCorridor)) {\n      const numVerticesInCorridor = corridor.length;\n      //console.log(`Found corridor of length ${numVerticesInCorridor}.`);\n      let lastCorridorFace = currentFace;\n      for (let i = 1; i < numVerticesInCorridor; i++) {\n        const corridorFace = corridor[i] as Face;\n        if (orderingGraph.faces.has(corridorFace)) {\n          throw new Error(\n            `Corridor face ${corridorFace.nodes.map(\n              n => n.id\n            )} was already visited.`\n          );\n        }\n        orderingGraph.addFace(corridorFace);\n        orderingGraph.addEdge(lastCorridorFace, corridorFace);\n\n        // See if we need to launch some more corridors after crossing a pseudohinge.\n        if (corridorFace.hasPseudohinge && lastCorridorFace.hasPseudohinge) {\n          const positiveDirection =\n            corridorFace.creaseToPreviousAxialFacet ==\n            lastCorridorFace.creaseToNextAxialFacet;\n          const negativeDirection =\n            corridorFace.creaseToNextAxialFacet ==\n            lastCorridorFace.creaseToPreviousAxialFacet;\n          if (positiveDirection == negativeDirection) {\n            throw new Error(\n              `Could not determine which way pseudohinge was crossed in going from face ${lastCorridorFace.nodes.map(\n                n => n.id\n              )} to face ${corridorFace.nodes.map(n => n.id)}.`\n            );\n          }\n          launchPseudohingeCorridors(\n            orderingGraph,\n            corridorFace,\n            positiveDirection\n          );\n        }\n\n        lastCorridorFace = corridorFace;\n      }\n    }\n\n    const nextFace = findNextNonPseudohingeFacet(\n      (currentFace.creaseToNextAxialFacet as Crease).getOtherFace(currentFace)\n    );\n    if (nextFace.isOuterFace) {\n      throw new Error(\n        `Next face from ${currentFace.nodes.map(\n          n => n.id\n        )} within same molecule is outer face.`\n      );\n    }\n    orderingGraph.addFace(nextFace);\n    const jumpToOtherMolecule = currentFace.crossAxialOrHull as Face;\n    if (\n      !(\n        jumpToOtherMolecule.isOuterFace ||\n        visitedMolecules.has(jumpToOtherMolecule.baseFaceLocalRoot as Face)\n      ) &&\n      isValidMOGMergePoint(currentFace)\n    ) {\n      // Can jump to a new neighboring molecule.\n      //console.log(`Jumping to new molecule.`);\n      orderingGraph.addFace(jumpToOtherMolecule);\n      orderingGraph.addEdge(currentFace, jumpToOtherMolecule);\n      buildROGRecursive(\n        orderingGraph,\n        visitedMolecules,\n        jumpToOtherMolecule.baseFaceLocalRoot as Face,\n        jumpToOtherMolecule,\n        globalSourceFace\n      );\n    } else {\n      // Keep going within the same molecule.\n      if (nextFace == mergePoint) {\n        // At merge point, add edge back to old molecule.\n        if (nextFace.isOuterFace) {\n          throw new Error(\n            `Should be merging back to old molecule, but face across axial/hull edge from ${currentFace.nodes.map(\n              n => n.id\n            )} is outer face.`\n          );\n        }\n        if (jumpToOtherMolecule != globalSourceFace) {\n          orderingGraph.addEdge(currentFace, jumpToOtherMolecule);\n        }\n      } else if (mergePoint == null && nextFace == sourceFace) {\n        // Done building entire ROG.\n        return;\n      } else {\n        // General case, add axial link to next axial facet.\n        orderingGraph.addEdge(currentFace, nextFace);\n      }\n      if (nextFace == sourceFace) {\n        // Done with molecule.\n        //console.log(`Jumping back to old molecule.`);\n        return;\n      }\n    }\n    currentFace = nextFace;\n  }\n  throw new Error(\"Caught in infinite loop while building an MOG.\");\n}\n\nexport function orderFacets(\n  g: CreasesGraph,\n  discreteDepth: Map<string, number>\n) {\n  if (g.state != CreasesGraphState.PreFacetOrdering) {\n    throw new Error(\n      `Should not be calling orderFacets from state ${\n        CreasesGraphState[g.state]\n      }.`\n    );\n  }\n\n  // Assign unfolded hinges.\n  const initialBaseFace = assignUnfoldedHinges(g, discreteDepth);\n  const initialFace = initialBaseFace.moleculeSource as Face;\n\n  // Build ROG.\n  //console.log(`Building ROG starting from ${initialFace.nodes.map(n => n.id)}.`);\n  const orderingGraph = new FacetOrderingGraph();\n  const visitedMolecules: Set<Face> = new Set();\n  buildROGRecursive(\n    orderingGraph,\n    visitedMolecules,\n    initialBaseFace,\n    null,\n    initialFace\n  );\n\n  // Sort ROG and set facet order indices for each face.\n  let facetOrderIndex = 0;\n  for (const face of orderingGraph.topologicalSort()) {\n    face.facetOrderIndex = facetOrderIndex++;\n  }\n  if (orderingGraph.faces.size != g.faces.size - 1) {\n    throw new Error(\n      `Expected to find all ${g.faces.size - 1} inner faces, instead found ${\n        orderingGraph.faces.size\n      }.`\n    );\n  }\n\n  // Assign all creases.\n  computeMVAssignmentRecursive(g, initialFace, true);\n\n  g.state = CreasesGraphState.FullyAssigned;\n}\n","import {\n  Node,\n  Edge,\n  Face,\n  TreeNode,\n  TreeEdge,\n  PackingNode,\n  Packing,\n  CreasesNode,\n  CreaseType,\n  MVAssignment,\n  Crease,\n  Graph,\n  TreeGraph,\n  CreasesGraphState,\n  CreasesGraph\n} from \"../../src/engine/packing\";\n\nexport function decode(\n  t: TreeGraph,\n  p: Packing,\n  g: CreasesGraph,\n  rootId\n): string {\n  let toReturn = `export function decodedTree() {\\n  const tree = new TreeGraph();\\n  tree.debugOverrideRootId = \"${rootId}\";`;\n  for (const [nodeId, node] of t.nodes) {\n    toReturn += `\\n  const v${nodeId} = new TreeNode(\"${nodeId}\", ${node.x}, ${node.y});\\n  tree.addNode(v${nodeId});`;\n  }\n  for (const edge of t.edges.values()) {\n    let leafExtension = 0;\n    for (const nodeId of [edge.from.id, edge.to.id]) {\n      const possibleLeafExtension = g.leafExtensions.get(\n        g.nodes.get(nodeId) as CreasesNode\n      );\n      if (possibleLeafExtension != undefined) {\n        leafExtension = possibleLeafExtension;\n        break;\n      }\n    }\n    toReturn += `\\n  tree.addEdge(new TreeEdge(v${edge.to.id}, v${\n      edge.from.id\n    }, ${edge.length + leafExtension}));`;\n  }\n  toReturn += `\\n  return tree;\\n}\\n\\nexport function decodedPacking() {\\n  const packing = new Packing();\\n  packing.scaleFactor = ${p.scaleFactor};`;\n  for (const [nodeId, node] of p.nodes) {\n    toReturn += `\\n  packing.nodes.set(\"${nodeId}\", new PackingNode(\"${nodeId}\", ${node.x}, ${node.y}));`;\n  }\n  toReturn += \"\\n  return packing;\\n}\";\n  return toReturn;\n}\n\nexport function fiveStarTree() {\n  const v1 = new TreeNode(\"1\", 0, 0);\n  const v2 = new TreeNode(\"2\", 1, 0);\n  const v3 = new TreeNode(\"3\", 0, 1);\n  const v4 = new TreeNode(\"4\", -1, 0);\n  const v5 = new TreeNode(\"5\", 0, -1);\n  const tree = new TreeGraph();\n  tree.addNode(v1);\n  tree.addNode(v2);\n  tree.addNode(v3);\n  tree.addNode(v4);\n  tree.addNode(v5);\n  const e2 = new TreeEdge(v2, v1, 3);\n  const e3 = new TreeEdge(v3, v1, 3);\n  const e4 = new TreeEdge(v4, v1, 3);\n  const e5 = new TreeEdge(v5, v1, 3);\n  tree.addEdge(e2);\n  tree.addEdge(e3);\n  tree.addEdge(e4);\n  tree.addEdge(e5);\n  return tree;\n}\n\nexport function fiveStarPacking() {\n  const v2 = new PackingNode(\"2\", 1, 0);\n  const v3 = new PackingNode(\"3\", 1, 1);\n  const v4 = new PackingNode(\"4\", 0, 1);\n  const v5 = new PackingNode(\"5\", 0, 0);\n  const packing = new Packing();\n  packing.scaleFactor = 1 / 6;\n  packing.nodes.set(\"2\", v2);\n  packing.nodes.set(\"3\", v3);\n  packing.nodes.set(\"4\", v4);\n  packing.nodes.set(\"5\", v5);\n  return packing;\n}\n\nexport function fiveStarBadPacking() {\n  const v2 = new PackingNode(\"2\", 0.5, 0);\n  const v3 = new PackingNode(\"3\", 0.5, 1);\n  const v4 = new PackingNode(\"4\", 0, 1);\n  const v5 = new PackingNode(\"5\", 0, 0);\n  const packing = new Packing();\n  packing.scaleFactor = 1 / 12;\n  packing.nodes.set(\"2\", v2);\n  packing.nodes.set(\"3\", v3);\n  packing.nodes.set(\"4\", v4);\n  packing.nodes.set(\"5\", v5);\n  return packing;\n}\n\nexport function starTree(lengths: number[]) {\n  const centralVertex = new TreeNode(\"0\", 0, 0);\n  const tree = new TreeGraph();\n  tree.addNode(centralVertex);\n  const angleDiff = Math.PI / lengths.length;\n  const angleInitial = angleDiff / 2 - Math.PI;\n  for (let i = 0; i < lengths.length; i++) {\n    const length = lengths[i] as number;\n    const angle = angleInitial + i * angleDiff;\n    const v = new TreeNode(\n      (i + 1).toString(),\n      length * Math.cos(angle),\n      length * Math.sin(angle)\n    );\n    tree.addNode(v);\n    const e = new TreeEdge(v, centralVertex, length);\n    tree.addEdge(e);\n  }\n  return tree;\n}\n\nexport function starPacking(scaleFactor: number, locations: number[][]) {\n  const packing = new Packing();\n  packing.scaleFactor = scaleFactor;\n  for (let i = 0; i < locations.length; i++) {\n    const [x, y] = locations[i];\n    const v = new PackingNode((i + 1).toString(), x, y);\n    packing.nodes.set(v.id, v);\n  }\n  return packing;\n}\n\nexport function threeNodeSuboptimalTree() {\n  return starTree([5, 2.5]);\n}\n\nexport function threeNodeSuboptimalPacking() {\n  return starPacking(1 / 16, [\n    [1, 0],\n    [11.5 / 16, 6 / 16]\n  ]);\n}\n\nexport function tenStarSuboptimalTree() {\n  return starTree([3, 2, 3, 3, 5, 2.5, 3, 2, 2, 5]);\n}\n\nexport function tenStarSuboptimalPacking() {\n  return starPacking(1 / 16, [\n    [0, 1],\n    [5 / 16, 1],\n    [10 / 16, 1],\n    [1, 1],\n    [0, 8 / 16],\n    [11.5 / 16, 6 / 16],\n    [0, 0],\n    [5 / 16, 0],\n    [9 / 16, 0],\n    [1, 0]\n  ]);\n}\n\nexport function rabbitEarOnSideTree() {\n  return starTree([1, 4, 4]);\n}\n\nexport function rabbitEarOnSidePacking() {\n  return starPacking(1 / 8, [\n    [1, 1 / 2],\n    [5 / 8, 0],\n    [5 / 8, 1]\n  ]);\n}\n\nexport function twoMoleculeTree() {\n  return starTree([1, 4, 1, 4]);\n}\n\nexport function twoMoleculePacking() {\n  return starPacking(1 / 8, [\n    [3 / 4, 1 / 2],\n    [3 / 8, 1],\n    [0, 1 / 2],\n    [3 / 8, 0]\n  ]);\n}\n\nexport function twoNodeTree() {\n  return starTree([2]);\n}\n\nexport function twoNodeAdjacentCornersPacking() {\n  const packing = new Packing();\n  packing.scaleFactor = 1 / 2;\n  const v0 = new PackingNode(\"0\", 1, 0);\n  packing.nodes.set(\"0\", v0);\n  const v1 = new PackingNode(\"1\", 1, 1);\n  packing.nodes.set(\"1\", v1);\n  return packing;\n}\n\nexport function demaineLangPaperSmallTree() {\n  const v1 = new TreeNode(\"1\", 0, 1);\n  const v2 = new TreeNode(\"2\", 1, 1);\n  const v3 = new TreeNode(\"3\", 0.5, 0.7);\n  const v4 = new TreeNode(\"4\", 0.5, 0.3);\n  const v5 = new TreeNode(\"5\", 0, 0);\n  const v6 = new TreeNode(\"6\", 0.5, 0);\n  const v7 = new TreeNode(\"7\", 1, 0);\n  const tree = new TreeGraph();\n  tree.addNode(v1);\n  tree.addNode(v2);\n  tree.addNode(v3);\n  tree.addNode(v4);\n  tree.addNode(v5);\n  tree.addNode(v6);\n  tree.addNode(v7);\n  const e13 = new TreeEdge(v3, v1, 1);\n  const e23 = new TreeEdge(v3, v2, 1);\n  const e34 = new TreeEdge(v4, v3, 1);\n  const e45 = new TreeEdge(v5, v4, 1);\n  const e46 = new TreeEdge(v6, v4, 1);\n  const e47 = new TreeEdge(v7, v4, 1);\n  tree.addEdge(e13);\n  tree.addEdge(e23);\n  tree.addEdge(e34);\n  tree.addEdge(e45);\n  tree.addEdge(e46);\n  tree.addEdge(e47);\n  return tree;\n}\n\nexport function demaineLangPaperSmallPacking() {\n  const packing = new Packing();\n  packing.scaleFactor = 0.2754;\n  const v1 = new PackingNode(\"1\", 0, 1);\n  packing.nodes.set(\"1\", v1);\n  const v2 = new PackingNode(\"2\", 0.551, 1);\n  packing.nodes.set(\"2\", v2);\n  const v5 = new PackingNode(\"5\", 0, 0.1);\n  packing.nodes.set(\"5\", v5);\n  const v6 = new PackingNode(\"6\", 0.5418, 0);\n  packing.nodes.set(\"6\", v6);\n  const v7 = new PackingNode(\"7\", 0.9999, 0.3061);\n  packing.nodes.set(\"7\", v7);\n  return packing;\n}\n\nexport function boneTree() {\n  const v1 = new TreeNode(\"1\", 0, 1);\n  const v2 = new TreeNode(\"2\", 1, 1);\n  const v3 = new TreeNode(\"3\", 0.5, 0.8);\n  const v4 = new TreeNode(\"4\", 0.5, 0.5);\n  const v5 = new TreeNode(\"5\", 0.5, 0.2);\n  const v6 = new TreeNode(\"6\", 0, 0);\n  const v7 = new TreeNode(\"7\", 1, 0);\n  const tree = new TreeGraph();\n  tree.addNode(v1);\n  tree.addNode(v2);\n  tree.addNode(v3);\n  tree.addNode(v4);\n  tree.addNode(v5);\n  tree.addNode(v6);\n  tree.addNode(v7);\n  const e13 = new TreeEdge(v3, v1, 2);\n  const e23 = new TreeEdge(v3, v2, 2);\n  const e34 = new TreeEdge(v4, v3, 1);\n  const e45 = new TreeEdge(v5, v4, 1);\n  const e56 = new TreeEdge(v6, v5, 2);\n  const e57 = new TreeEdge(v7, v5, 2);\n  tree.addEdge(e13);\n  tree.addEdge(e23);\n  tree.addEdge(e34);\n  tree.addEdge(e45);\n  tree.addEdge(e56);\n  tree.addEdge(e57);\n  return tree;\n}\n\nexport function bonePacking() {\n  const packing = new Packing();\n  packing.scaleFactor = 1 / 6;\n  const v1 = new PackingNode(\"1\", 0, 1);\n  packing.nodes.set(\"1\", v1);\n  const v2 = new PackingNode(\"2\", 2 / 3, 1);\n  packing.nodes.set(\"2\", v2);\n  const v6 = new PackingNode(\"6\", 0, 0);\n  packing.nodes.set(\"6\", v6);\n  const v7 = new PackingNode(\"7\", 2 / 3, 0);\n  packing.nodes.set(\"7\", v7);\n  return packing;\n}\n\nexport function twistedBonePacking() {\n  const packing = new Packing();\n  packing.scaleFactor = 1 / 15;\n  const v1 = new PackingNode(\"1\", 0.3, 0.7);\n  packing.nodes.set(\"1\", v1);\n  const v7 = new PackingNode(\"7\", 0.7, 0.7);\n  packing.nodes.set(\"7\", v7);\n  const v6 = new PackingNode(\"6\", 0.3, 0.3);\n  packing.nodes.set(\"6\", v6);\n  const v2 = new PackingNode(\"2\", 0.7, 0.3);\n  packing.nodes.set(\"2\", v2);\n  return packing;\n}\n\nexport function crabTree() {\n  // Crab design by Jason Ku shown in lecture.\n  const vertices = [\n    [0, 0],\n    [4.5, 0],\n    [6.5, 0],\n    [8.5, 0],\n    [13, 0],\n    [0, -2],\n    [1.5, -3.5],\n    [3, -4.5],\n    [13, -2],\n    [11.5, -3.5],\n    [10, -4.5],\n    [6.5, 3],\n    [8.5, 1],\n    [5.5, 4],\n    [6.5, 4.5],\n    [7.5, 4],\n    [4.5, 3],\n    [2.5, 5.5],\n    [4.5, 7],\n    [4, 6],\n    [8.5, 3],\n    [10.5, 5.5],\n    [8.5, 7],\n    [9, 6]\n  ];\n  const adjacency = [\n    [0, 1],\n    [1, 2],\n    [1, 5],\n    [1, 6],\n    [1, 7],\n    [2, 3],\n    [2, 11],\n    [3, 4],\n    [3, 8],\n    [3, 9],\n    [3, 10],\n    [11, 12],\n    [11, 13],\n    [11, 14],\n    [11, 15],\n    [11, 16],\n    [11, 20],\n    [16, 17],\n    [17, 18],\n    [17, 19],\n    [20, 21],\n    [21, 22],\n    [21, 23]\n  ];\n  const tree = new TreeGraph();\n  const nodes: TreeNode[] = [];\n  for (const [idx, coords] of vertices.entries()) {\n    const v = new TreeNode(idx.toString(), coords[0], coords[1]);\n    nodes.push(v);\n    tree.addNode(v);\n  }\n  for (const e of adjacency) {\n    const nodeFrom = nodes[e[0]];\n    const nodeTo = nodes[e[1]];\n    const length = Math.sqrt(\n      Math.pow(nodeFrom.x - nodeTo.x, 2) + Math.pow(nodeFrom.y - nodeTo.y, 2)\n    );\n    tree.addEdge(new TreeEdge(nodeFrom, nodeTo, length));\n  }\n  return tree;\n}\n\nexport function crossingSwordsTree() {\n  const v1 = new TreeNode(\"1\", 0, 0);\n  const v2 = new TreeNode(\"2\", -3, -3);\n  const v3 = new TreeNode(\"3\", 3, -3);\n  const v4 = new TreeNode(\"4\", -1, 1);\n  const v5 = new TreeNode(\"5\", 1, 1);\n  const v6 = new TreeNode(\"6\", -4, -2);\n  const v7 = new TreeNode(\"7\", -4, -4);\n  const v8 = new TreeNode(\"8\", -2, -4);\n  const v9 = new TreeNode(\"9\", 4, -2);\n  const v10 = new TreeNode(\"10\", 4, -4);\n  const v11 = new TreeNode(\"11\", 2, -4);\n  const v12 = new TreeNode(\"12\", -5, -3);\n  const tree = new TreeGraph();\n  tree.addNode(v1);\n  tree.addNode(v2);\n  tree.addNode(v3);\n  tree.addNode(v4);\n  tree.addNode(v5);\n  tree.addNode(v6);\n  tree.addNode(v7);\n  tree.addNode(v8);\n  tree.addNode(v9);\n  tree.addNode(v10);\n  tree.addNode(v11);\n  tree.addNode(v12);\n  tree.addEdge(new TreeEdge(v2, v1, 3));\n  tree.addEdge(new TreeEdge(v3, v1, 3));\n  tree.addEdge(new TreeEdge(v4, v1, 1));\n  tree.addEdge(new TreeEdge(v5, v1, 1));\n  tree.addEdge(new TreeEdge(v6, v2, 1));\n  tree.addEdge(new TreeEdge(v7, v2, 1));\n  tree.addEdge(new TreeEdge(v8, v2, 1));\n  tree.addEdge(new TreeEdge(v9, v3, 1));\n  tree.addEdge(new TreeEdge(v10, v3, 1));\n  tree.addEdge(new TreeEdge(v11, v3, 1));\n  tree.addEdge(new TreeEdge(v12, v2, 3));\n  return tree;\n}\n\nexport function crossingSwordsPacking() {\n  const packing = new Packing();\n  packing.scaleFactor = 1 / 12;\n  packing.nodes.set(\"4\", new PackingNode(\"4\", 8 / 12, 9 / 12));\n  packing.nodes.set(\"5\", new PackingNode(\"5\", 8 / 12, 3 / 12));\n  packing.nodes.set(\"6\", new PackingNode(\"6\", 4 / 12, 12 / 12));\n  packing.nodes.set(\"7\", new PackingNode(\"7\", 4 / 12, 6 / 12));\n  packing.nodes.set(\"8\", new PackingNode(\"8\", 4 / 12, 0 / 12));\n  packing.nodes.set(\"9\", new PackingNode(\"9\", 12 / 12, 12 / 12));\n  packing.nodes.set(\"10\", new PackingNode(\"10\", 12 / 12, 6 / 12));\n  packing.nodes.set(\"11\", new PackingNode(\"11\", 12 / 12, 0 / 12));\n  packing.nodes.set(\"12\", new PackingNode(\"12\", 0 / 12, 6 / 12));\n  return packing;\n}\n\nexport function pseudohingeElevationBugTree() {\n  const v1 = new TreeNode(\"1\", -1, 1);\n  const v2 = new TreeNode(\"2\", 0, 0);\n  const v3 = new TreeNode(\"3\", -2, 2);\n  const v4 = new TreeNode(\"4\", -1, -1);\n  const v5 = new TreeNode(\"5\", 1, 1);\n  const tree = new TreeGraph();\n  tree.addNode(v1);\n  tree.addNode(v2);\n  tree.addNode(v3);\n  tree.addNode(v4);\n  tree.addNode(v5);\n  tree.addEdge(new TreeEdge(v2, v1, 0.6));\n  tree.addEdge(new TreeEdge(v3, v1, 0.25));\n  tree.addEdge(new TreeEdge(v4, v2, 0.15));\n  tree.addEdge(new TreeEdge(v5, v2, 0.15));\n  return tree;\n}\n\nexport function pseudohingeElevationBugPacking() {\n  const packing = new Packing();\n  packing.scaleFactor = 1;\n  packing.nodes.set(\"3\", new PackingNode(\"3\", 0, 1));\n  packing.nodes.set(\"4\", new PackingNode(\"4\", 0, 0));\n  packing.nodes.set(\"5\", new PackingNode(\"5\", 1, 1));\n  return packing;\n}\n\nexport function mogMergeBugSimpleTree() {\n  const tree = new TreeGraph();\n  tree.debugOverrideRootId = \"1\";\n  const v1 = new TreeNode(\"1\", 0, 0);\n  tree.addNode(v1);\n  const v2 = new TreeNode(\"2\", 0, 1);\n  tree.addNode(v2);\n  const v3 = new TreeNode(\"3\", 2, 2);\n  tree.addNode(v3);\n  const v4 = new TreeNode(\"4\", -2, 2);\n  tree.addNode(v4);\n  const v5 = new TreeNode(\"5\", -1, -1);\n  tree.addNode(v5);\n  const v6 = new TreeNode(\"6\", 1, -1);\n  tree.addNode(v6);\n  tree.addEdge(new TreeEdge(v2, v1, 1));\n  tree.addEdge(new TreeEdge(v3, v2, 10));\n  tree.addEdge(new TreeEdge(v4, v2, 10));\n  tree.addEdge(new TreeEdge(v5, v1, 1));\n  tree.addEdge(new TreeEdge(v6, v1, 1));\n  return tree;\n}\n\nexport function mogMergeBugSimplePacking() {\n  const packing = new Packing();\n  packing.scaleFactor = 1 / 16;\n  packing.nodes.set(\"3\", new PackingNode(\"3\", 3 / 4, 1));\n  packing.nodes.set(\"5\", new PackingNode(\"5\", 0, 1));\n  packing.nodes.set(\"4\", new PackingNode(\"4\", 0, 0));\n  packing.nodes.set(\"6\", new PackingNode(\"6\", 3 / 4, 0));\n  return packing;\n}\n\nexport function treeTheoremCounterexampleTree() {\n  const tree = new TreeGraph();\n  tree.debugOverrideRootId = \"1\";\n  const v1 = new TreeNode(\"1\", 0, 0);\n  tree.addNode(v1);\n  const v2 = new TreeNode(\"2\", 1, 0);\n  tree.addNode(v2);\n  const v3 = new TreeNode(\"3\", 1, 2);\n  tree.addNode(v3);\n  const v4 = new TreeNode(\"4\", 3, 0);\n  tree.addNode(v4);\n  const v5 = new TreeNode(\"5\", -5, 0);\n  tree.addNode(v5);\n  const v6 = new TreeNode(\"6\", 0, 5);\n  tree.addNode(v6);\n  tree.addEdge(new TreeEdge(v2, v1, 1));\n  tree.addEdge(new TreeEdge(v3, v2, 2));\n  tree.addEdge(new TreeEdge(v4, v2, 2));\n  tree.addEdge(new TreeEdge(v5, v1, 5));\n  tree.addEdge(new TreeEdge(v6, v1, 5));\n  return tree;\n}\n\nexport function treeTheoremCounterexamplePacking() {\n  const packing = new Packing();\n  packing.scaleFactor = 1 / 8;\n  packing.nodes.set(\"3\", new PackingNode(\"3\", 0, 1));\n  packing.nodes.set(\"5\", new PackingNode(\"5\", 0, 0));\n  packing.nodes.set(\"4\", new PackingNode(\"4\", 1, 0));\n  packing.nodes.set(\"6\", new PackingNode(\"6\", 1, 1));\n  return packing;\n}\n\nexport function decodedTestTree() {\n  const tree = new TreeGraph();\n  tree.debugOverrideRootId = \"1\";\n  const v1 = new TreeNode(\"1\", 5, 4);\n  tree.addNode(v1);\n  const v2 = new TreeNode(\"2\", 4.910714285714286, 7.700892857142858);\n  tree.addNode(v2);\n  const v3 = new TreeNode(\"3\", 2.96875, 2.834821428571429);\n  tree.addNode(v3);\n  const v4 = new TreeNode(\"4\", 5.111607142857143, 2.299107142857143);\n  tree.addNode(v4);\n  const v5 = new TreeNode(\"5\", 6.808035714285714, 2.879464285714286);\n  tree.addNode(v5);\n  const v6 = new TreeNode(\"6\", 3.5267857142857144, 8.705357142857144);\n  tree.addNode(v6);\n  const v7 = new TreeNode(\"7\", 5.915178571428572, 8.705357142857144);\n  tree.addNode(v7);\n  tree.addEdge(new TreeEdge(v1, v4, 2.387976429952156));\n  tree.addEdge(new TreeEdge(v3, v1, 3.3701006940340474));\n  tree.addEdge(new TreeEdge(v1, v5, 3.1272107631640544));\n  tree.addEdge(new TreeEdge(v1, v2, 3.701969729593495));\n  tree.addEdge(new TreeEdge(v2, v6, 3.42057599122217));\n  tree.addEdge(new TreeEdge(v2, v7, 3.1400255076229553));\n  return tree;\n}\n\nexport function decodedTestPacking() {\n  const packing = new Packing();\n  packing.scaleFactor = 0.06998501126871456;\n  packing.nodes.set(\n    \"3\",\n    new PackingNode(\"3\", -2.64378557934819e-9, 0.6449532240035764)\n  );\n  packing.nodes.set(\n    \"4\",\n    new PackingNode(\"4\", 0.4152402487712022, 0.6369842363991575)\n  );\n  packing.nodes.set(\"5\", new PackingNode(\"5\", 0.28408974824848027, 1));\n  packing.nodes.set(\n    \"6\",\n    new PackingNode(\"6\", 0.9999999982410215, 0.954901533967804)\n  );\n  packing.nodes.set(\"7\", new PackingNode(\"7\", 0.30793237713994537, 0));\n  return packing;\n}\n\nexport function decodedNotADagErrorTree() {\n  const tree = new TreeGraph();\n  tree.debugOverrideRootId = \"1\";\n  const v1 = new TreeNode(\"1\", 5, 4);\n  tree.addNode(v1);\n  const v2 = new TreeNode(\"2\", 5, 6);\n  tree.addNode(v2);\n  const v3 = new TreeNode(\"3\", 3.5267857142857144, 3.035714285714286);\n  tree.addNode(v3);\n  const v4 = new TreeNode(\"4\", 6.026785714285714, 3.325892857142857);\n  tree.addNode(v4);\n  const v5 = new TreeNode(\"5\", 6.026785714285714, 6.71875);\n  tree.addNode(v5);\n  const v6 = new TreeNode(\"6\", 4.776785714285714, 7.343750000000001);\n  tree.addNode(v6);\n  const v7 = new TreeNode(\"7\", 2.03125, 6.227678571428572);\n  tree.addNode(v7);\n  const v8 = new TreeNode(\"8\", 2.1205357142857144, 7.276785714285714);\n  tree.addNode(v8);\n  const v9 = new TreeNode(\"9\", 0.9375000000000001, 6.40625);\n  tree.addNode(v9);\n  const v10 = new TreeNode(\"10\", 2.1205357142857144, 2.96875);\n  tree.addNode(v10);\n  const v11 = new TreeNode(\"11\", 2.834821428571429, 2.1651785714285716);\n  tree.addNode(v11);\n  const v12 = new TreeNode(\"12\", 1.1607142857142858, 2.232142857142857);\n  tree.addNode(v12);\n  tree.addEdge(new TreeEdge(v1, v4, 15.761812131503053));\n  tree.addEdge(new TreeEdge(v3, v1, 39.726212926513504));\n  tree.addEdge(new TreeEdge(v1, v2, 2));\n  tree.addEdge(new TreeEdge(v2, v6, 46.46729352139373));\n  tree.addEdge(new TreeEdge(v5, v2, 37.36025003041873));\n  tree.addEdge(new TreeEdge(v2, v7, 2.9774677318801888));\n  tree.addEdge(new TreeEdge(v7, v9, 15.001887942990807));\n  tree.addEdge(new TreeEdge(v8, v7, 1.1443317883360984));\n  tree.addEdge(new TreeEdge(v7, v10, 3.260151433974959));\n  tree.addEdge(new TreeEdge(v10, v11, 62.276098123250016));\n  tree.addEdge(new TreeEdge(v10, v12, 153.78043821836764));\n  return tree;\n}\n\nexport function decodedNotADagErrorPacking() {\n  const packing = new Packing();\n  packing.scaleFactor = 0.00445064931456961;\n  packing.nodes.set(\"11\", new PackingNode(\"11\", 0.6002975636558101, 1));\n  packing.nodes.set(\n    \"12\",\n    new PackingNode(\"12\", -1.8485998287687266e-9, 0.24879978192179975)\n  );\n  packing.nodes.set(\n    \"3\",\n    new PackingNode(\"3\", 0.999999999208625, 0.7154567587617131)\n  );\n  packing.nodes.set(\n    \"4\",\n    new PackingNode(\"4\", 0.7971095092142312, 0.5746605416350531)\n  );\n  packing.nodes.set(\n    \"5\",\n    new PackingNode(\"5\", 0.932417886312053, 0.3700195268893871)\n  );\n  packing.nodes.set(\n    \"6\",\n    new PackingNode(\"6\", 0.8846741930276222, 2.0510018683417286e-9)\n  );\n  packing.nodes.set(\"8\", new PackingNode(\"8\", 1, 0.1933763774956242));\n  packing.nodes.set(\n    \"9\",\n    new PackingNode(\"9\", 0.6547918075274544, 0.6457195548347869)\n  );\n  return packing;\n}\n\nexport function decodedMogMergeBug2Tree() {\n  const tree = new TreeGraph();\n  tree.debugOverrideRootId = \"1\";\n  const v1 = new TreeNode(\"1\", 4.888392857142858, 2.700892857142857);\n  tree.addNode(v1);\n  const v2 = new TreeNode(\"2\", 5, 6);\n  tree.addNode(v2);\n  const v3 = new TreeNode(\"3\", 8.616071428571429, 8.191964285714286);\n  tree.addNode(v3);\n  const v4 = new TreeNode(\"4\", 1.049107142857143, 7.924107142857143);\n  tree.addNode(v4);\n  const v5 = new TreeNode(\"5\", 3.6830357142857144, 1.5401785714285716);\n  tree.addNode(v5);\n  const v6 = new TreeNode(\"6\", 5.803571428571429, 1.4732142857142858);\n  tree.addNode(v6);\n  const v7 = new TreeNode(\"7\", 9.441964285714286, 6.9419642857142865);\n  tree.addNode(v7);\n  const v8 = new TreeNode(\"8\", 1.8080357142857144, 8.59375);\n  tree.addNode(v8);\n  const v9 = new TreeNode(\"9\", 0.5133928571428572, 8.459821428571429);\n  tree.addNode(v9);\n  const v10 = new TreeNode(\"10\", 0.625, 6.651785714285714);\n  tree.addNode(v10);\n  const v11 = new TreeNode(\"11\", 9.53125, 8.4375);\n  tree.addNode(v11);\n  const v12 = new TreeNode(\"12\", 8.482142857142858, 8.839285714285715);\n  tree.addNode(v12);\n  const v13 = new TreeNode(\"13\", 4.821428571428572, 1.09375);\n  tree.addNode(v13);\n  tree.addEdge(new TreeEdge(v2, v1, 3.3009944099297948));\n  tree.addEdge(new TreeEdge(v1, v6, 6.790156953778052));\n  tree.addEdge(new TreeEdge(v5, v1, 9.193741447416954));\n  tree.addEdge(new TreeEdge(v1, v13, 29.37348750180522));\n  tree.addEdge(new TreeEdge(v2, v4, 4.39451279049411));\n  tree.addEdge(new TreeEdge(v2, v3, 4.228555309603689));\n  tree.addEdge(new TreeEdge(v3, v11, 4.013923428191168));\n  tree.addEdge(new TreeEdge(v7, v3, 25.764524269447353));\n  tree.addEdge(new TreeEdge(v3, v12, 9.981490229297913));\n  tree.addEdge(new TreeEdge(v4, v9, 25.628450492576142));\n  tree.addEdge(new TreeEdge(v8, v4, 8.563558530127219));\n  tree.addEdge(new TreeEdge(v4, v10, 14.287958914386362));\n  return tree;\n}\n\nexport function decodedMogMergeBug2Packing() {\n  const packing = new Packing();\n  packing.scaleFactor = 0.01293291920705089;\n  packing.nodes.set(\n    \"10\",\n    new PackingNode(\"10\", 0.45204563121333136, 0.4384670865022129)\n  );\n  packing.nodes.set(\n    \"11\",\n    new PackingNode(\"11\", 0.6738868305005234, -2.5512846696384983e-9)\n  );\n  packing.nodes.set(\"12\", new PackingNode(\"12\", 0.6121828388798757, 1));\n  packing.nodes.set(\n    \"13\",\n    new PackingNode(\"13\", 0.005829033300032704, 1.0000000018326995)\n  );\n  packing.nodes.set(\n    \"5\",\n    new PackingNode(\"5\", 0.800870184838832, 0.236225659232633)\n  );\n  packing.nodes.set(\"6\", new PackingNode(\"6\", 1, 0.1807293425767597));\n  packing.nodes.set(\n    \"7\",\n    new PackingNode(\"7\", 0.9999999986489463, 0.7483664685765745)\n  );\n  packing.nodes.set(\n    \"8\",\n    new PackingNode(\"8\", 0.39970182944998894, 2.014007613460045e-9)\n  );\n  packing.nodes.set(\"9\", new PackingNode(\"9\", 0, 0.1891599604850908));\n  return packing;\n}\n\nexport function decodedWhereDoFlapsGoTree() {\n  const tree = new TreeGraph();\n  tree.debugOverrideRootId = \"1\";\n  const v1 = new TreeNode(\"1\", 5, 4);\n  tree.addNode(v1);\n  const v2 = new TreeNode(\"2\", 5, 6);\n  tree.addNode(v2);\n  const v3 = new TreeNode(\"3\", 2.8125, 2.96875);\n  tree.addNode(v3);\n  const v4 = new TreeNode(\"4\", 6.40625, 1.986607142857143);\n  tree.addNode(v4);\n  const v5 = new TreeNode(\"5\", 7.477678571428572, 4.665178571428572);\n  tree.addNode(v5);\n  const v6 = new TreeNode(\"6\", 6.517857142857143, 6.450892857142858);\n  tree.addNode(v6);\n  const v7 = new TreeNode(\"7\", 8.950892857142858, 5.46875);\n  tree.addNode(v7);\n  const v8 = new TreeNode(\"8\", 7.589285714285714, 2.7678571428571432);\n  tree.addNode(v8);\n  tree.addEdge(new TreeEdge(v2, v1, 18.3535269088408));\n  tree.addEdge(new TreeEdge(v1, v4, 5.374958203338106));\n  tree.addEdge(new TreeEdge(v3, v1, 4.343574713529792));\n  tree.addEdge(new TreeEdge(v1, v5, 2.565414905079505));\n  tree.addEdge(new TreeEdge(v5, v7, 9.725527648642851));\n  tree.addEdge(new TreeEdge(v6, v5, 5.485700768590421));\n  tree.addEdge(new TreeEdge(v5, v8, 10.733303331582217));\n  return tree;\n}\n\nexport function decodedWhereDoFlapsGoPacking() {\n  const packing = new Packing();\n  packing.scaleFactor = 0.031701175524034175;\n  packing.nodes.set(\n    \"2\",\n    new PackingNode(\"2\", 1.0000000000569993, 0.836799711012014)\n  );\n  packing.nodes.set(\n    \"3\",\n    new PackingNode(\"3\", 0.4630704572433471, 0.35781891059362164)\n  );\n  packing.nodes.set(\n    \"4\",\n    new PackingNode(\"4\", 0.5585535539217014, 0.06489953680507765)\n  );\n  packing.nodes.set(\n    \"6\",\n    new PackingNode(\"6\", 0.9791987885239919, 7.367175203221166e-10)\n  );\n  packing.nodes.set(\n    \"7\",\n    new PackingNode(\"7\", -4.2213310624816813e-10, 0.10553605968356494)\n  );\n  packing.nodes.set(\n    \"8\",\n    new PackingNode(\"8\", -1.261446724853954e-9, 0.7541050516042278)\n  );\n  return packing;\n}\n\nexport function decodedBadCorridorAfterPseudohingeTree() {\n  const tree = new TreeGraph();\n  tree.debugOverrideRootId = \"4\";\n  const v1 = new TreeNode(\"1\", 5, 4);\n  tree.addNode(v1);\n  const v2 = new TreeNode(\"2\", 5, 6);\n  tree.addNode(v2);\n  const v5 = new TreeNode(\"5\", 4.5504087193460485, 2.506811989100817);\n  tree.addNode(v5);\n  const v6 = new TreeNode(\"6\", 5.640326975476839, 3.215258855585831);\n  tree.addNode(v6);\n  const v3 = new TreeNode(\"3\", 3.514986376021798, 7.275204359673024);\n  tree.addNode(v3);\n  const v4 = new TreeNode(\"4\", 6.076294277929155, 7.68392370572207);\n  tree.addNode(v4);\n  const v7 = new TreeNode(\"7\", 7.1117166212534055, 7.68392370572207);\n  tree.addNode(v7);\n  const v8 = new TreeNode(\"8\", 6.757493188010899, 8.77384196185286);\n  tree.addNode(v8);\n  const v9 = new TreeNode(\"9\", 3.1335149863760217, 8.119891008174386);\n  tree.addNode(v9);\n  const v10 = new TreeNode(\"10\", 2.7247956403269753, 6.975476839237056);\n  tree.addNode(v10);\n  tree.addEdge(new TreeEdge(v1, v5, 4.150476717883663));\n  tree.addEdge(new TreeEdge(v1, v6, 2.654521076821072));\n  tree.addEdge(new TreeEdge(v1, v2, 2));\n  tree.addEdge(new TreeEdge(v2, v4, 1.9985015435059814));\n  tree.addEdge(new TreeEdge(v2, v3, 1.9573991985106054));\n  tree.addEdge(new TreeEdge(v3, v9, 0.9529317277948539));\n  tree.addEdge(new TreeEdge(v3, v10, 1.1282162660313555));\n  tree.addEdge(new TreeEdge(v4, v7, 1.0631695901529052));\n  tree.addEdge(new TreeEdge(v4, v8, 3.6352767380799076));\n  return tree;\n}\n\nexport function decodedBadCorridorAfterPseudohingePacking() {\n  const packing = new Packing();\n  packing.scaleFactor = 0.0873900315629287;\n  packing.nodes.set(\n    \"10\",\n    new PackingNode(\"10\", 0.9999999971164418, 0.13695020600926255)\n  );\n  packing.nodes.set(\"5\", new PackingNode(\"5\", 0, 0.10156788020638523));\n  packing.nodes.set(\n    \"6\",\n    new PackingNode(\"6\", -3.017856131659613e-9, 0.6962568522712922)\n  );\n  packing.nodes.set(\"7\", new PackingNode(\"7\", 0.6020342518673453, 1));\n  packing.nodes.set(\n    \"8\",\n    new PackingNode(\"8\", 0.9999999986129633, 0.8989383006929783)\n  );\n  packing.nodes.set(\"9\", new PackingNode(\"9\", 0.8803257897397259, 0));\n  return packing;\n}\n\nexport function decodedFlapErrorTree() {\n  const tree = new TreeGraph();\n  tree.debugOverrideRootId = \"4\";\n  const v1 = new TreeNode(\"1\", 5, 4);\n  tree.addNode(v1);\n  const v2 = new TreeNode(\"2\", 5, 6);\n  tree.addNode(v2);\n  const v3 = new TreeNode(\"3\", 5, 7.991071428571429);\n  tree.addNode(v3);\n  const v4 = new TreeNode(\"4\", 5, 9.866071428571429);\n  tree.addNode(v4);\n  const v5 = new TreeNode(\"5\", 5.5357142857142865, 9.834821428571429);\n  tree.addNode(v5);\n  const v6 = new TreeNode(\"6\", 4.352678571428572, 9.879464285714286);\n  tree.addNode(v6);\n  const v7 = new TreeNode(\"7\", 4.955357142857143, 10.392857142857144);\n  tree.addNode(v7);\n  const v8 = new TreeNode(\"8\", 5.513392857142858, 3.964285714285715);\n  tree.addNode(v8);\n  const v9 = new TreeNode(\"9\", 4.955357142857143, 3.406250000000001);\n  tree.addNode(v9);\n  const v10 = new TreeNode(\"10\", 4.308035714285714, 3.9866071428571437);\n  tree.addNode(v10);\n  tree.addEdge(new TreeEdge(v2, v1, 2));\n  tree.addEdge(new TreeEdge(v1, v9, 2.2413076213123433));\n  tree.addEdge(new TreeEdge(v8, v1, 0.7314333376758668));\n  tree.addEdge(new TreeEdge(v1, v10, 0.9531987704627167));\n  tree.addEdge(new TreeEdge(v2, v3, 1.9910714285714288));\n  tree.addEdge(new TreeEdge(v3, v4, 1.875));\n  tree.addEdge(new TreeEdge(v4, v6, 2.0751210197251186));\n  tree.addEdge(new TreeEdge(v5, v4, 1.2556198652167678));\n  tree.addEdge(new TreeEdge(v4, v7, 0.5520475898760828));\n  return tree;\n}\n\nexport function decodedFlapErrorPacking() {\n  const packing = new Packing();\n  packing.scaleFactor = 0.11243569783630102;\n  packing.nodes.set(\"10\", new PackingNode(\"10\", 0.9909635975273698, 0));\n  packing.nodes.set(\"5\", new PackingNode(\"5\", 0.606765195254479, 0.99999999958552));\n  packing.nodes.set(\"6\", new PackingNode(\"6\", 0.981259370964819, 0.9999999986121055));\n  packing.nodes.set(\"7\", new PackingNode(\"7\", 1.0975217956676886e-10, 0.9898039861901106));\n  packing.nodes.set(\"8\", new PackingNode(\"8\", -3.1243979625728e-10, 0.18593907781220848));\n  packing.nodes.set(\"9\", new PackingNode(\"9\", 0.277749007128965, 1.927828507941598e-9));\n  return packing;\n}\n","\n\n\n\n\nimport { Component, Prop, Vue } from \"vue-property-decorator\";\nimport { JSXGraph, Board } from \"jsxgraph\";\nimport { saveAs } from \"file-saver\";\nimport { generateFold } from \"../engine/creases/export\";\nimport {\n  TreeGraph,\n  CreasesGraph,\n  Packing,\n  CreaseType,\n  MVAssignment,\n  Crease,\n  CreasesNode\n} from \"../engine/packing\";\nimport { generateMolecules, cleanPacking, buildFaces } from \"../engine/creases\";\nimport { orderFacets } from \"../engine/creases/ordering\";\n\nimport {\n  tenStarSuboptimalTree,\n  tenStarSuboptimalPacking,\n  twoNodeTree,\n  twoNodeAdjacentCornersPacking,\n  rabbitEarOnSideTree,\n  rabbitEarOnSidePacking,\n  demaineLangPaperSmallTree,\n  demaineLangPaperSmallPacking,\n  boneTree,\n  bonePacking,\n  crossingSwordsTree,\n  crossingSwordsPacking,\n  pseudohingeElevationBugTree,\n  pseudohingeElevationBugPacking,\n  decode,\n  decodedTestTree,\n  decodedTestPacking,\n  decodedNotADagErrorTree,\n  decodedNotADagErrorPacking,\n  decodedWhereDoFlapsGoTree,\n  decodedWhereDoFlapsGoPacking,\n  decodedMogMergeBug2Tree,\n  decodedMogMergeBug2Packing,\n  mogMergeBugSimpleTree,\n  mogMergeBugSimplePacking,\n  decodedBadCorridorAfterPseudohingeTree,\n  decodedBadCorridorAfterPseudohingePacking,\n  treeTheoremCounterexampleTree,\n  treeTheoremCounterexamplePacking,\n  decodedFlapErrorTree,\n  decodedFlapErrorPacking\n} from \"../../tests/helper\";\n\nfunction getColor(e: Crease, useMV: boolean): string {\n  if (useMV) {\n    switch (e.assignment) {\n      case MVAssignment.Mountain:\n        return \"#ee6666\";\n      case MVAssignment.Valley:\n        return \"#0021e6\";\n      case MVAssignment.Unfolded:\n        return \"#ccffcc\";\n      case MVAssignment.Boundary:\n        return \"#333333\";\n      case MVAssignment.Unknown:\n        // We shouldn't be seeing this if facet ordering is working.\n        return \"#ffb000\";\n    }\n  } else {\n    switch (e.creaseType) {\n      case CreaseType.Ridge:\n        return \"#ee6666\";\n      case CreaseType.Gusset:\n        return \"#0021e6\";\n      case CreaseType.Pseudohinge:\n        return \"#419cc3\";\n      case CreaseType.Hinge:\n        return \"#7744a6\";\n      case CreaseType.Axial:\n        return \"#333333\";\n      case CreaseType.ActiveHull:\n        return \"#333333\";\n      case CreaseType.InactiveHull:\n        return \"#333333\";\n    }\n  }\n}\n@Component\nexport default class CreasesView extends Vue {\n  creasesBoard: Board;\n  fold: object | undefined;\n  simulator: Window | null | undefined;\n\n  mounted() {\n    const creasesBoard = JSXGraph.initBoard(\"creasesViewBox\", {\n      boundingbox: [-0.1, 1.1, 1.1, -0.1],\n      showCopyright: false\n      //showNavigation: false\n    });\n    creasesBoard.create(\"grid\", []);\n    this.creasesBoard = creasesBoard;\n  }\n\n  show() {\n    // TODO Make these parameters interactive.\n    const paramShowFacetOrder = true; // Overlay ROG in pink.\n    const paramShowMVAssignmentOnly = true; // Color all creases as red or blue.\n    const paramDisplayInternalNodes = true; // Show labels of branch nodes.\n\n    if ((this.$store.state as any).packingCreasesSynced === true) {\n      return; // No need to update.\n    }\n\n    this.$store.commit(\"clearGlobalError\");\n    const creasesBoard = JSXGraph.initBoard(\"creasesViewBox\", {\n      boundingbox: [-0.1, 1.1, 1.1, -0.1],\n      showCopyright: false\n      //showNavigation: false\n    });\n    creasesBoard.create(\"grid\", []);\n\n    const treeGraph = (this.$store.state as any).treeGraph as TreeGraph;\n    const creasesGraph = (this.$store.state as any)\n      .creasesGraph as CreasesGraph;\n    const distances = treeGraph.getDistances();\n    const rootId = creasesGraph.findAGoodRoot(distances);\n    const discreteDepth = treeGraph.dangle(rootId);\n    const packing = (this.$store.state as any).packing as Packing;\n    console.log(decode(treeGraph, packing, creasesGraph, rootId));\n\n    /*/ Replace the lines above with these to visualize a hard-coded test case; also need to change exportDisabled in TreeFaker.vue if you want to be able to open in Origami Simulator.\n    const treeGraph = decodedFlapErrorTree();\n    const packing = decodedFlapErrorPacking();\n    const distances = treeGraph.getDistances();\n    const creasesGraph = cleanPacking(packing, distances);\n    const discreteDepth = treeGraph.dangle(creasesGraph.findAGoodRoot(distances));\n    const errorMessage = buildFaces(creasesGraph);\n    if (errorMessage != null) {\n      this.$store.commit(\n        \"updateGlobalError\",\n        \"Debug buildFaces error. (\" + errorMessage + \")\"\n      );\n      return;\n    }*/\n\n    // TODO (@pjrule): the UMA mutates objects in place, so we\n    // should make deep copies here to avoid inadvertently mutating global state.\n    try {\n      generateMolecules(\n        creasesGraph,\n        distances,\n        packing.scaleFactor,\n        discreteDepth\n      );\n    } catch (err) {\n      this.$store.commit(\n        \"updateGlobalError\",\n        \"Could not generate molecules. (\" + err.message + \")\"\n      );\n      return;\n    }\n    try {\n      orderFacets(creasesGraph, discreteDepth);\n    } catch (err) {\n      this.$store.commit(\n        \"updateGlobalError\",\n        \"Could not order facets. (\" + err.message + \")\"\n      );\n    }\n    const points: Map<CreasesNode, any> = new Map();\n    for (const v of creasesGraph.nodes.values()) {\n      const vertexName =\n        !paramDisplayInternalNodes && v.id.charAt(0) == \"i\" ? \"\" : v.displayId; // TODO Change to v.id for debugging, then change back to v.displayId when done.\n      if (v.id == v.displayId) {\n        // Leaf node.\n        const point = creasesBoard.create(\"point\", [v.x, v.y], {\n          name: vertexName,\n          fixed: true,\n          highlight: false,\n          label: { offset: [6, 6], highlight: false }\n        });\n        points.set(v, point);\n      } else {\n        const point = creasesBoard.create(\"point\", [v.x, v.y], {\n          name: vertexName,\n          fixed: true,\n          size: 0,\n          highlight: false,\n          label: { offset: [0, 0], highlight: false }\n        });\n        points.set(v, point);\n      }\n    }\n    for (const edge of creasesGraph.edges.values()) {\n      const v1 = edge.to as CreasesNode;\n      const v2 = edge.from as CreasesNode;\n      const p1 = points.get(v1);\n      const p2 = points.get(v2);\n      const color = getColor(edge, paramShowMVAssignmentOnly);\n      creasesBoard.create(\"segment\", [p1, p2], {\n        strokeColor: color,\n        strokeWidth: 2,\n        highlight: false\n      });\n    }\n\n    // Visualize facet order.\n    if (paramShowFacetOrder) {\n      const faces = Array.from(creasesGraph.faces).sort(\n        (f1, f2) => f1.facetOrderIndex - f2.facetOrderIndex\n      );\n      faces.shift();\n      let p1: any = null;\n      for (const face of faces) {\n        if (face.facetOrderIndex >= 0) {\n          if (p1 == null) {\n            p1 = creasesBoard.create(\n              \"point\",\n              [face.averageX(), face.averageY()],\n              {\n                name: \"\",\n                strokeColor: \"#ff00e6\",\n                fillColor: \"#ff00e6\",\n                fixed: true,\n                highlight: false\n              }\n            );\n          } else {\n            const p2 = creasesBoard.create(\n              \"point\",\n              [face.averageX(), face.averageY()],\n              {\n                name: \"\",\n                fixed: true,\n                size: 0,\n                highlight: false\n              }\n            );\n            creasesBoard.create(\"segment\", [p1, p2], {\n              strokeColor: \"#ff00e6\",\n              strokeWidth: 1,\n              highlight: false\n            });\n            p1 = p2;\n          }\n        } else {\n          creasesBoard.create(\"point\", [face.averageX(), face.averageY()], {\n            name: \"\",\n            strokeColor: \"#ff00e6\",\n            fillColor: \"#ff00e6\",\n            fixed: true,\n            highlight: false\n          });\n        }\n      }\n    }\n\n    this.creasesBoard = creasesBoard;\n    this.fold = generateFold(creasesGraph);\n    this.$store.commit(\"sync\");\n  }\n\n  download() {\n    if (this.fold !== undefined) {\n      const blob = new Blob([JSON.stringify(this.fold)], {\n        type: \"application.json;charset=utf-8\"\n      });\n      saveAs(blob, \"treefaker.fold\");\n    }\n  }\n\n  origamiSimulator() {\n    if (this.fold !== undefined) {\n      // POSTing to Origami Simulator: see @edemaine's Maze Font tool, etc.\n      if (\n        this.simulator !== null &&\n        this.simulator !== undefined &&\n        !this.simulator.closed\n      ) {\n        this.simulator.focus();\n        this.simulator.postMessage({ op: \"importFold\", fold: this.fold }, \"*\");\n      } else {\n        this.simulator = window.open(\n          \"https://origamisimulator.org/?model=treefaker\"\n        );\n        const fold = this.fold;\n        const simulator = this.simulator;\n        window.addEventListener(\"message\", function(e) {\n          if (\n            simulator !== null &&\n            e.source === simulator &&\n            e.data &&\n            e.data.from === \"OrigamiSimulator\" &&\n            e.data.status === \"ready\"\n          ) {\n            simulator.postMessage({ op: \"importFold\", fold: fold }, \"*\");\n          }\n        });\n      }\n    }\n  }\n}\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./CreasesView.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./CreasesView.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./CreasesView.vue?vue&type=template&id=d46c1de6&\"\nimport script from \"./CreasesView.vue?vue&type=script&lang=ts&\"\nexport * from \"./CreasesView.vue?vue&type=script&lang=ts&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"viewBox\",attrs:{\"id\":\"packingViewBox\"}})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","/**\n * Augmented Lagrangian methods for disk packing.\n *\n * This is essentially a reimplementation of Robert J. Lang's\n * augmented Lagrangian + line search solver.\n */\nimport { matrix, zeros, size } from \"mathjs\";\nimport { TreeGraph } from \".\";\n\ntype PackingMap = Map<string, Map<string, Array<[string, number]>>>;\ntype Constraint = (X: matrix) => number;\ntype GradConstraint = (X: matrix) => matrix;\ntype ConstraintSet = {\n  constraints: Constraint[];\n  grad: GradConstraint[];\n};\n\nconst MAX_SCALE = 2;\n\nfunction lbConstraint(idx: number, lb: number): Constraint {\n  return function(X: matrix): number {\n    if (X[idx] < lb) {\n      return lb - X[idx];\n    }\n    return 0;\n  };\n}\n\nfunction gradLbConstraint(idx: number, lb: number, n: number): GradConstraint {\n  return function(X: matrix): number {\n    const deriv = zeros([n]);\n    if (X[idx] < lb) {\n      deriv[idx] = -1;\n    }\n    return deriv;\n  };\n}\n\nfunction ubConstraint(idx: number, ub: number): Constraint {\n  return function(X: matrix): number {\n    if (X[idx] > ub) {\n      return X[idx] - ub;\n    }\n    return 0;\n  };\n}\n\nfunction gradUbConstraint(idx: number, ub: number, n: number): GradConstraint {\n  return function(X: matrix): number {\n    const deriv = zeros([n]);\n    if (X[idx] > ub) {\n      deriv[idx] = 1;\n    }\n    return deriv;\n  };\n}\n\nfunction overlapConstraint(dists: matrix, i: number, j: number): Constraint {\n  const n = size(dists)[0];\n  const length = dists[i][j];\n  return function(X: matrix): number {\n    const scale = X[2 * n];\n    const dist = Math.sqrt(\n      Math.pow(X[i] - X[j], 2) + Math.pow(X[i + n] - X[j + n], 2)\n    );\n    const scaledLength = scale * length;\n    return scaledLength - dist;\n  };\n}\n\nfunction gradOverlapConstraint(\n  dists: matrix,\n  i: number,\n  j: number\n): GradConstraint {\n  const n = size(dists)[0];\n  const length = dists[i][j];\n  return function(X: matrix): matrix {\n    const dist = Math.sqrt(\n      Math.pow(X[i] - X[j], 2) + Math.pow(X[i + n] - X[j + n], 2)\n    );\n    const invDist = 1 / dist;\n    const deriv = zeros([2 * n + 1]);\n    deriv[i] = invDist * (X[j] - X[i]);\n    deriv[j] = invDist * (X[i] - X[j]);\n    deriv[i + n] = invDist * (X[j + n] - X[i + n]);\n    deriv[j + n] = invDist * (X[i + n] - X[j + n]);\n    deriv[2 * n] = length;\n    return deriv;\n  };\n}\n\nfunction genConstraints(dists: matrix): Constraint[] {\n  const n = size(dists)[0];\n  const lbConstraints = Array(2 * n)\n    .fill(null)\n    .map((_, i) => lbConstraint(i, 0));\n  const ubConstraints = Array(2 * n)\n    .fill(null)\n    .map((_, i) => ubConstraint(i, 1));\n  const overlapConstraints: Constraint[] = [];\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      overlapConstraints.push(overlapConstraint(dists, i, j));\n    }\n  }\n  return [\n    lbConstraint(2 * n, 0),\n    ubConstraint(2 * n, MAX_SCALE),\n    ...lbConstraints,\n    ...ubConstraints,\n    ...overlapConstraints\n  ];\n}\n\nfunction genGradConstraints(dists: matrix): GradConstraint[] {\n  const n = size(dists)[0];\n  const gradLbConstraints = Array(2 * n)\n    .fill(null)\n    .map((_, i) => gradLbConstraint(i, 0, 2 * n + 1));\n  const gradUbConstraints = Array(2 * n)\n    .fill(null)\n    .map((_, i) => gradUbConstraint(i, 1, 2 * n + 1));\n  const gradOverlapConstraints: GradConstraint[] = [];\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      gradOverlapConstraints.push(gradOverlapConstraint(dists, i, j));\n    }\n  }\n  return [\n    gradLbConstraint(2 * n, 0, 2 * n + 1),\n    gradUbConstraint(2 * n, MAX_SCALE, 2 * n + 1),\n    ...gradLbConstraints,\n    ...gradUbConstraints,\n    ...gradOverlapConstraints\n  ];\n}\n\nfunction toMatrix(nodes: PackingMap): matrix {\n  const keys = Array.from(nodes.keys()).sort();\n  const n = keys.length;\n  const dists = zeros([n, n]);\n\n  for (let i = 0; i < n; i++) {\n    const iKey = keys[i];\n    for (let j = 0; j < n; j++) {\n      const jKey = keys[j];\n      if (i !== j) {\n        const distancesAlongPath = nodes.get(iKey)?.get(jKey) as Array<\n          [string, number]\n        >;\n        dists[i][j] = (distancesAlongPath[distancesAlongPath.length - 1] as [\n          string,\n          number\n        ])[1] as number;\n      }\n    }\n  }\n  return dists;\n}\n\nexport {\n  PackingMap,\n  Constraint,\n  GradConstraint,\n  ConstraintSet,\n  lbConstraint,\n  ubConstraint,\n  overlapConstraint,\n  gradLbConstraint,\n  gradUbConstraint,\n  gradOverlapConstraint,\n  genConstraints,\n  genGradConstraints,\n  toMatrix\n};\n","/**\n * An augmented Lagrangian-based solver for disk packing.\n * Ported nearly verbatim from Robert J. Lang's TreeMaker v5.\n * (TODO: any necessary licensing notes before public release.)\n */\nimport {\n  matrix,\n  zeros,\n  ones,\n  size,\n  norm,\n  dot,\n  abs,\n  min,\n  max,\n  multiply,\n  dotDivide,\n  add,\n  diag,\n  subtract,\n  clone,\n  index,\n  subset,\n  range,\n  flatten\n} from \"mathjs\";\nimport { Constraint, ConstraintSet } from \"./constraints\";\n\ntype Step = {\n  X: matrix;\n  f: number;\n  grad: matrix;\n};\n\n/* Optimization hyperparameters. */\n// Outer search parameters (Augmented Lagrangian coefficients).\nconst WEIGHT_START = 10;\nconst WEIGHT_RATIO = 10;\nconst WEIGHT_MAX = 1e8;\nconst ITERS_OUTER = 50;\n\n// Inner search parameters\nconst ITERS_INNER = 100;\n// How much (relatively) does the objective value need to decrease\n// to terminate an instance of line search?\nconst ALF = 1e-4;\n\n// Convergence tolerances.\nconst EPS = Number.EPSILON;\nconst X_TOL = 4 * EPS;\nconst G_TOL = 1e-5;\n\nfunction maxStepSize(X: matrix): number {\n  // We assume that each of the `n` points has an associated\n  // eslint-disable-next-line no-irregular-whitespace\n  // upper and lower bound such that 0 ≤ x_i, y_i ≤ 1.\n  // Following Lang, we choose the maximum step size to be the length\n  // of a diagonal in the 2n-dimensional hypercube [0, 1] x ... [0 x 1].\n  const n = (size(X) - 1) / 2;\n  return Math.sqrt(2 * n);\n}\n\nfunction augLag(\n  X: matrix,\n  constraints: ConstraintSet,\n  mult: matrix,\n  weight: number\n): number {\n  const n = (size(X) - 1) / 2;\n  let total = -X[2 * n]; // objective: maximize scale factor\n  // We assume that all constraints are inequality constraints.\n  for (const [i, fn] of constraints.constraints.entries()) {\n    const lm = mult[i];\n    const val = fn(X);\n    const mu = (-0.5 * lm) / weight;\n    total += val < mu ? mu : (lm + val * weight) * val;\n  }\n  return total;\n}\n\nfunction gradAugLag(\n  X: matrix,\n  constraints: ConstraintSet,\n  mult: matrix,\n  weight: number\n): matrix {\n  const n = (size(X) - 1) / 2;\n  let grad = zeros([2 * n + 1]);\n  grad[2 * n] = -1; // gradient of objective (maximize scale factor)\n  for (const [i, fn] of constraints.constraints.entries()) {\n    const lm = mult[i];\n    const val = fn(X);\n    const mu = (-0.5 * lm) / weight;\n    if (val >= mu) {\n      const gradMul = lm + 2 * val * weight;\n      if (Math.abs(gradMul) > X_TOL) {\n        const gradFn = constraints.grad[i];\n        const gradVal = gradFn(X);\n        grad = add(grad, multiply(gradMul, gradVal));\n      }\n    }\n  }\n  return grad;\n}\n\nfunction updateMultipliers(\n  X: matrix,\n  constraints: ConstraintSet,\n  oldMult: matrix,\n  weight: number\n): matrix {\n  const newMult = clone(oldMult);\n  for (const [i, fn] of constraints.constraints.entries()) {\n    const f = fn(X);\n    const mu = (-0.5 * oldMult[i]) / weight;\n    if (f < mu) {\n      newMult[i] = 0;\n    } else {\n      newMult[i] += 2 * weight * f;\n    }\n  }\n  return newMult;\n}\n\nfunction outer(v1: matrix, v2: matrix): matrix | undefined {\n  /* Computes the outer product of two vectors. */\n  if (size(v1).length !== 1 || size(v2).length !== 1) {\n    // Operation only defined on vectors.\n    return undefined;\n  }\n  const s1 = size(v1)[0];\n  const s2 = size(v2)[0];\n  const res = ones([s1, s2]);\n  for (let i = 0; i < s1; i++) {\n    for (let j = 0; j < s2; j++) {\n      res[i][j] = v1[i] * v2[j];\n    }\n  }\n  return res;\n}\n\nexport function rescaleSol(X: matrix, dists: matrix): matrix {\n  /**\n   * Coerce a solution to be valid by scaling points to [0, 1] x [0, 1]\n   * and computing the optimal scale factor.\n   */\n  const n = (size(X)[0] - 1) / 2;\n  let xCoords = subset(X, index(range(0, n)));\n  let yCoords = subset(X, index(range(n, 2 * n)));\n\n  const xMin = min(xCoords);\n  const yMin = min(yCoords);\n  xCoords = subtract(xCoords, xMin);\n  yCoords = subtract(yCoords, yMin);\n\n  const scale = 1 / max(max(xCoords), max(yCoords));\n  xCoords = multiply(scale, xCoords);\n  yCoords = multiply(scale, yCoords);\n  const packingDists = zeros([n, n]);\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      const dist = Math.sqrt(\n        Math.pow(xCoords[i] - xCoords[j], 2) +\n          Math.pow(yCoords[i] - yCoords[j], 2)\n      );\n      packingDists[i][j] = dist;\n      packingDists[j][i] = dist;\n    }\n  }\n  const ratio =\n    min(\n      flatten(dotDivide(packingDists, dists)).filter((x: number) => !isNaN(x))\n    ) / 2;\n  return [...xCoords, ...yCoords, ratio];\n}\n\nfunction lineSearch(\n  old: Step,\n  searchDirection: matrix,\n  constraints: ConstraintSet,\n  mult: matrix,\n  weight: number\n): Step | undefined {\n  //console.log(\"\\t--- minimizing along line ---\");\n  const searchNorm = norm(searchDirection);\n  let scale = 1;\n  const maxStep = maxStepSize(old.X);\n  if (searchNorm > maxStep) {\n    scale = maxStep / searchNorm;\n  }\n\n  // Stop if going uphill.\n  const slope = dot(old.grad, multiply(scale, searchDirection));\n  if (slope >= 0) {\n    return old;\n  }\n\n  const minStep =\n    EPS /\n    max(\n      dotDivide(\n        abs(searchDirection),\n        max([abs(old.X), ones([size(old.X)[0]])], 0)\n      ),\n      0\n    );\n  /*\n  console.log(\"\\tsearch direction:\", searchDirection);\n  console.log(\"\\tscale:\", scale);\n  console.log(\"\\tinitial slope:\", slope);\n  console.log(\"\\tminimum step size\", minStep);\n  */\n\n  let lm = 1.0; // step size relative to a full Newton step.\n  let lastLm = 0.0; // last step size\n  let lastF = 0.0; // last augmented Lagrangian function value\n  let lastX = old.X;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    // Take a step along the search direction.\n    const XNew = add(old.X, multiply(scale * lm, searchDirection));\n    const fNew = augLag(XNew, constraints, mult, weight);\n    /*\n    console.log(\"lm:\", lm);\n    console.log(\"\\t\\tX:\", XNew);\n    console.log(\"\\t\\tf:\", fNew);\n    */\n\n    const fTarget = lastF + ALF * lm * slope;\n    if (lm < minStep) {\n      // Quit once the step size is below the minimum tolerance.\n      // Use the last iteration (known good).\n      break;\n    } else if (fNew <= fTarget) {\n      // We've made sufficient progress in this iteration; terminate.\n      return {\n        X: XNew,\n        f: fNew,\n        grad: gradAugLag(XNew, constraints, mult, weight)\n      };\n    } else {\n      // The hard part: do a backtracking step.\n      let nextLm: number | undefined = undefined;\n      if (lm === 1.0) {\n        nextLm = -slope / (2 * (fNew - old.f - slope));\n      } else {\n        const rhs1 = fNew - old.f - lm * slope;\n        const rhs2 = lastF - old.f - lastLm * slope;\n        const lmSq = Math.pow(lm, 2);\n        const lastLmSq = Math.pow(lastLm, 2);\n        const lmDelta = lm - lastLm;\n        const a = (rhs1 / lmSq - rhs2 / lastLmSq) / lmDelta;\n        const b = ((-lastLm * rhs1) / lmSq + (lm * rhs2) / lastLmSq) / lmDelta;\n        if (a === 0) {\n          nextLm = -slope / (2 * b);\n        } else {\n          const discr = Math.pow(b, 2) - 3 * a * slope;\n          if (discr < 0) {\n            nextLm = lm / 2;\n          } else if (b <= 0.0) {\n            nextLm = (-b + Math.sqrt(discr)) / (3 * a);\n          } else {\n            nextLm = -slope / (b + Math.sqrt(discr));\n          }\n          nextLm = Math.min(nextLm, lm / 2);\n        }\n      }\n      lastLm = lm;\n      lastF = fNew;\n      lastX = XNew;\n      lm = Math.max(nextLm, lm / 10);\n    }\n  }\n  return {\n    X: lastX,\n    f: lastF,\n    grad: gradAugLag(lastX, constraints, mult, weight)\n  };\n}\n\nfunction minimizeAugLag(\n  last: Step,\n  constraints: ConstraintSet,\n  mult: matrix,\n  weight: number\n): Step | undefined {\n  let lastStep = last;\n  let searchDirection = multiply(\n    -1,\n    gradAugLag(last.X, constraints, mult, weight)\n  );\n  let hessInv = diag(ones([size(last.grad)[0]]));\n  for (let iter = 1; iter <= ITERS_INNER; iter++) {\n    //console.log(\"\\t--- inner iteration\", iter, \"---\");\n    const nextStep = lineSearch(\n      lastStep,\n      searchDirection,\n      constraints,\n      mult,\n      weight\n    );\n    //console.log(\"\\t\", nextStep);\n    if (nextStep === undefined) {\n      // Something went wrong in the inner optimization step.\n      // Propagate the error upward.\n      return undefined;\n    }\n    searchDirection = subtract(nextStep.X, lastStep.X);\n\n    // Test for convergence of step size.\n    const xTest = max(\n      dotDivide(\n        abs(searchDirection),\n        max([abs(nextStep.X), ones([size(nextStep.X)[0]])], 0)\n      )\n    );\n    if (xTest < X_TOL) {\n      break;\n    }\n\n    // Test for convergence to zero gradient.\n    const gTest =\n      max(\n        multiply(\n          abs(nextStep.grad),\n          max([abs(nextStep.X), ones([size(nextStep.X)[0]])], 0)\n        )\n      ) / Math.max(nextStep.f, 1);\n    if (gTest < G_TOL) {\n      break;\n    }\n\n    // Compute dot products used in Hessian update denominators.\n    const gradDelta = subtract(nextStep.grad, lastStep.grad);\n    const hdg = multiply(hessInv, gradDelta);\n    const fac = dot(gradDelta, searchDirection);\n    const fae = dot(gradDelta, hdg);\n    const sumDg = Math.pow(norm(gradDelta), 2);\n    const sumXi = Math.pow(norm(searchDirection), 2);\n\n    // Update the inverse Hessian.\n    /*\n    console.log(\"fac:\", fac);\n    console.log(\"fae:\", fae);\n    console.log(\"sumDg:\", sumDg);\n    console.log(\"sumXi:\", sumXi);\n    */\n\n    if (fac > Math.sqrt(EPS * sumDg * sumXi)) {\n      const facInv = 1.0 / fac;\n      const fad = 1.0 / fae;\n      const dg = subtract(\n        multiply(facInv, searchDirection),\n        multiply(fad, hdg)\n      );\n      const hessInvDelta = subtract(\n        add(\n          multiply(facInv, outer(searchDirection, searchDirection)),\n          multiply(fae, outer(dg, dg))\n        ),\n        multiply(fad, outer(hdg, hdg))\n      );\n      hessInv = add(hessInv, hessInvDelta);\n      //console.log(\"\\tinverse Hessian delta:\", hessInvDelta);\n    }\n    //console.log(\"\\tinverse Hessian:\", hessInv);\n    //console.log(\"\\tgradient:\", nextStep.grad);\n    searchDirection = multiply(hessInv, multiply(-1, nextStep.grad));\n    lastStep = nextStep;\n  }\n  return lastStep;\n}\n\nexport function solve(\n  X: matrix,\n  dists: matrix,\n  constraints: ConstraintSet\n): matrix | undefined {\n  const nConstraints = constraints.constraints.length;\n  let mult = zeros([nConstraints]);\n  let weight = WEIGHT_START;\n  //const scaledX = rescaleSol(X, dists);\n  let lastStep = {\n    X: X,\n    f: augLag(X, constraints, mult, weight),\n    grad: gradAugLag(X, constraints, mult, weight)\n  };\n  let bestObjVal: number | undefined = 0;\n  let bestSol: matrix | undefined = undefined;\n\n  for (let iter = 0; iter < ITERS_OUTER; iter++) {\n    //console.log(\"--- outer iteration\", iter, \"---\");\n    const unscaledNextStep = minimizeAugLag(\n      lastStep,\n      constraints,\n      mult,\n      weight\n    );\n    //console.log(\"unscaled:\", unscaledNextStep);\n    if (unscaledNextStep === undefined) {\n      // Something went wrong in the inner optimization step. :(\n      return undefined;\n    }\n    const nextStep = unscaledNextStep; /*{\n      X: X,\n      f: augLag(X, constraints, mult, weight),\n      grad: gradAugLag(X, constraints, mult, weight),\n    };*/\n    //console.log(\"scaled:\", nextStep);\n    const feasibility = max(\n      max(constraints.constraints.map((con: Constraint) => con(nextStep.X))),\n      0\n    );\n    mult = updateMultipliers(nextStep.X, constraints, mult, weight);\n\n    // TODO (@pjrule): allow for arbitrary objective functions.\n    // (For our first version, we are primarily concerned with\n    //  maximizing the scale factor.)\n    const nextObjVal = -nextStep.X[size(nextStep.X)[0] - 1];\n    //console.log(\"\\tfeasibility:\", feasibility);\n    //console.log(\"\\tobj:\", nextObjVal);\n\n    if (iter > 0 && feasibility < G_TOL && bestObjVal > nextObjVal) {\n      // Terminate if the solution is feasible and has converged\n      // to a local minimum.\n      bestSol = nextStep.X;\n      bestObjVal = nextObjVal;\n      //console.log(\"new best feasible solution found\");\n    }\n    weight = Math.min(weight * WEIGHT_RATIO, WEIGHT_MAX);\n    lastStep = nextStep;\n  }\n  return bestSol;\n}\n","\n\n\n\n\nimport Vuex from \"vuex\";\nimport { Component, Prop, Vue } from \"vue-property-decorator\";\nimport { JSXGraph, Board } from \"jsxgraph\";\nimport { zeros, size, random, add, multiply, matrix } from \"mathjs\";\nimport {\n  Packing,\n  PackingNode,\n  TreeGraph,\n  TreeNode,\n  CreasesGraph\n} from \"../engine/packing\";\nimport {\n  genConstraints,\n  genGradConstraints,\n  toMatrix\n} from \"../engine/packing/constraints\";\nimport { solve } from \"../engine/packing/alm\";\nimport { cleanPacking, buildFaces, isTwisted } from \"../engine/creases\";\n\n@Component\nexport default class PackingView extends Vue {\n  packingBoard: Board;\n\n  constructor() {\n    super();\n    this.packingBoard = null;\n  }\n\n  clear() {\n    const packingBoard = JSXGraph.initBoard(\"packingViewBox\", {\n      boundingbox: [-0.05, 1.05, 1.05, -0.05],\n      showCopyright: false,\n      showNavigation: false\n    });\n    packingBoard.create(\"grid\", []);\n    this.packingBoard = packingBoard;\n  }\n\n  mounted() {\n    this.clear();\n  }\n\n  async pack() {\n    // TODO (@pjrule): this is not strictly view code and should\n    // almost certainly be moved to the engine (perhaps as a method of `Packing`).\n    this.$store.commit(\"clearGlobalError\");\n    this.clear();\n    const PERTURB_EPS = 1e-3;\n\n    // Construct the optimization problem.\n    const treeGraph = (this.$store.state as any).treeGraph as TreeGraph;\n    const leafLengths = new Map();\n    treeGraph.nodes.forEach((node: TreeNode, key: string) => {\n      if (node.edges.length === 1) {\n        leafLengths.set(key, node.edges[0].length);\n      }\n    });\n    const d = treeGraph.getDistances();\n    if (d.size === treeGraph.nodes.size) {\n      this.$store.commit(\n        \"updateGlobalError\",\n        \"Add at least one non-leaf vertex to the tree.\"\n      );\n      return;\n    }\n    const distanceMatrix = toMatrix(d);\n\n    // Generate an initial solution from the user's placement of the nodes.\n    const n = size(distanceMatrix)[0];\n    const initSol = zeros([2 * n + 1]);\n    const vKeys = Array.from(d.keys()).sort();\n    const nodes = (this.$store.state as any).treeGraph.nodes;\n    vKeys.forEach(function(key, idx) {\n      initSol[idx] = nodes.get(key).x;\n      initSol[idx + n] = nodes.get(key).y;\n    });\n\n    // Generate a (not necessarily optimal) disk packing.\n    // If the solver fails to converge, perturb the problem slightly and retry.\n    return new Promise(resolve => {\n      let twisted = true;\n      let finalErrorMessage = \"Did not update error message.\";\n      for (let attempt = 0; twisted && attempt < 6; attempt++) {\n        let sol: matrix | undefined = undefined;\n        for (let trial = 0; trial < 6 && sol === undefined; trial++) {\n          const perturbedDists = add(\n            distanceMatrix,\n            multiply(PERTURB_EPS, random(size(distanceMatrix)))\n          );\n          const perturbedConstraints = {\n            constraints: genConstraints(perturbedDists),\n            grad: genGradConstraints(perturbedDists)\n          };\n          const perturbedInitSol = add(\n            initSol,\n            multiply(PERTURB_EPS, random(size(initSol)))\n          );\n          sol = solve(perturbedInitSol, perturbedDists, perturbedConstraints);\n        }\n        if (sol === undefined) {\n          this.$store.commit(\n            \"updateGlobalError\",\n            \"Could not generate disk packing from tree.\"\n          );\n          return;\n        }\n\n        const packing = new Packing();\n        packing.scaleFactor = sol[2 * n];\n        for (let i = 0; i < n; i++) {\n          // TODO (@pjrule): better typing here?\n          const id = vKeys[i] as string;\n          const x = sol[i];\n          const y = sol[i + n];\n          packing.nodes.set(id, new PackingNode(id, x, y));\n        }\n\n        // Clean up the packing to enforce active path invariants.\n        let cleanedPackingCreasesGraph: null | CreasesGraph = null;\n        try {\n          cleanedPackingCreasesGraph = cleanPacking(packing, d);\n        } catch (err) {\n          this.$store.commit(\n            \"updateGlobalError\",\n            \"Could not clean packing. '\" + err.message + \"'\"\n          );\n          return;\n        }\n\n        // Compute convex hull and active polygons.\n        try {\n          const possibleErrorMessage = buildFaces(cleanedPackingCreasesGraph);\n          if (possibleErrorMessage != null) {\n            finalErrorMessage = possibleErrorMessage;\n            continue;\n          }\n        } catch (err) {\n          this.$store.commit(\n            \"updateGlobalError\",\n            \"Could not build faces: '\" + err.message + \"'\"\n          );\n          return;\n        }\n\n        if (isTwisted(d, cleanedPackingCreasesGraph)) {\n          finalErrorMessage = \"Tree is twisted.\";\n          continue;\n        }\n        twisted = false;\n        this.$store.commit(\"updatePacking\", packing);\n        this.$store.commit(\"updateCreasesGraph\", cleanedPackingCreasesGraph);\n        this.$store.commit(\"unsync\");\n\n        // Display the packing.\n        // TODO (@pjrule): would it be more efficient to reuse the old board?\n        const creasesGraph = (this.$store.state as any)\n          .creasesGraph as CreasesGraph;\n        const packingBoard = JSXGraph.initBoard(\"packingViewBox\", {\n          boundingbox: [-0.1, 1.1, 1.1, -0.1],\n          showCopyright: false,\n          showNavigation: false\n        });\n        packingBoard.create(\"grid\", []);\n        creasesGraph.nodes.forEach(function(v) {\n          const center = packingBoard.create(\"point\", [v.x, v.y], {\n            name: v.id,\n            label: { offset: [6, 6], highlight: false },\n            highlight: false,\n            fixed: true\n          });\n          const radius =\n            (leafLengths.get(v.id) + creasesGraph.leafExtensions.get(v)) *\n            packing.scaleFactor;\n          packingBoard.create(\"circle\", [center, radius], {\n            fixed: true,\n            strokeColor: \"#0021e6\",\n            highlight: false\n          });\n        });\n        this.packingBoard = packingBoard;\n      }\n      if (twisted) {\n        this.$store.commit(\n          \"updateGlobalError\",\n          \"Could not find packing. Error message from final attempt: '\" +\n            finalErrorMessage +\n            \"'\"\n        );\n      }\n      resolve(1);\n    });\n  }\n}\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./PackingView.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./PackingView.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./PackingView.vue?vue&type=template&id=60c7fec4&\"\nimport script from \"./PackingView.vue?vue&type=script&lang=ts&\"\nexport * from \"./PackingView.vue?vue&type=script&lang=ts&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { Component, Prop, Vue } from \"vue-property-decorator\";\nimport TreeView from './TreeView.vue';\nimport CreasesView from './CreasesView.vue';\nimport PackingView from './PackingView.vue';\nimport { BAlert, BButton, BSpinner, ModalPlugin, NavbarPlugin } from 'bootstrap-vue';\nimport { CreasesGraphState } from '../engine/packing';\n\nVue.component('b-alert', BAlert)\nVue.component('b-button', BButton);\nVue.component('b-spinner', BSpinner);\nVue.use(ModalPlugin);\nVue.use(NavbarPlugin);\n \n@Component({\n  components: {\n    TreeView,\n    CreasesView,\n    PackingView\n  }\n})\nexport default class TreeFaker extends Vue {\n  generatingPacking = false;\n\n  async generatePacking() {\n    //this.generatingPacking = true;\n    //this.$forceUpdate();\n    (this.$refs as any).tree.propagate();\n    await (this.$refs as any).packing.pack();\n    //this.generatingPacking = false;\n  }\n  getCreasePattern() {\n    (this.$refs as any).creases.show();\n  }\n  exportFold() {\n    (this.$refs as any).creases.download();\n  }\n  origamiSimulator() {\n    (this.$refs as any).creases.origamiSimulator();\n  }\n  get creasesDisabled() {\n      return (this.$store as any).state.creasesGraph === undefined;\n  }\n  get exportDisabled() {\n    return (\n      //(this.$store as any).state.creasesGraph === undefined ||\n      //(this.$store as any).state.creasesGraph.state !== CreasesGraphState.FullyAssigned\n      false\n    );\n  }\n  get inErrorState() {\n    return (this.$store as any).state.globalError !== undefined;\n  }\n  get errorMessage() {\n    return (this.$store as any).state.globalError;\n  }\n}\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./TreeFaker.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./TreeFaker.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./TreeFaker.vue?vue&type=template&id=2c5bd63a&\"\nimport script from \"./TreeFaker.vue?vue&type=script&lang=ts&\"\nexport * from \"./TreeFaker.vue?vue&type=script&lang=ts&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","\n\n\n\n\nimport { Component, Vue } from \"vue-property-decorator\";\nimport TreeFaker from \"./components/TreeFaker.vue\";\nimport { BootstrapVue } from \"bootstrap-vue\";\n\nVue.use(BootstrapVue);\n\n@Component({\n  components: {\n    TreeFaker\n  }\n})\nexport default class App extends Vue {}\n","import mod from \"-!../node_modules/cache-loader/dist/cjs.js??ref--14-0!../node_modules/thread-loader/dist/cjs.js!../node_modules/babel-loader/lib/index.js!../node_modules/ts-loader/index.js??ref--14-3!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../node_modules/cache-loader/dist/cjs.js??ref--14-0!../node_modules/thread-loader/dist/cjs.js!../node_modules/babel-loader/lib/index.js!../node_modules/ts-loader/index.js??ref--14-3!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./App.vue?vue&type=template&id=2db7fbb6&\"\nimport script from \"./App.vue?vue&type=script&lang=ts&\"\nexport * from \"./App.vue?vue&type=script&lang=ts&\"\n\n\n/* normalize component */\nimport normalizer from \"!../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","import Vue from \"vue\";\nimport Vuex, { StoreOptions } from \"vuex\";\nimport App from \"./App.vue\";\nimport \"./assets/css/origamiSimulator/nav.css\";\nimport \"./assets/css/origamiSimulator/main.css\";\nimport \"./assets/css/jsxgraph.css\";\nimport \"bootstrap/dist/css/bootstrap.css\";\nimport \"bootstrap-vue/dist/bootstrap-vue.css\";\nimport \"./assets/css/style.css\";\nimport { TreeGraph, CreasesGraph, Packing } from \"./engine/packing\";\n\nVue.use(Vuex);\nVue.config.productionTip = false;\n\n// Typing a Vuex store:\n// https://codeburst.io/vuex-and-typescript-3427ba78cfa8\nexport type RootState = {\n  treeGraph: TreeGraph | undefined;\n  creasesGraph: CreasesGraph | undefined;\n  packing: Packing | undefined;\n  globalError: string | undefined;\n  packingCreasesSynced: boolean;\n};\n\nconst storeTemplate: StoreOptions<RootState> = {\n  state: {\n    // The raw tree, as constructed by the user.\n    treeGraph: undefined,\n\n    // The cleaned-up packing, ready to be converted into creases.\n    // TODO: is this name too confusing?\n    creasesGraph: undefined,\n\n    packing: undefined,\n    globalError: undefined,\n    packingCreasesSynced: false\n  },\n  mutations: {\n    updateTreeGraph(state, graph: TreeGraph) {\n      state.treeGraph = graph;\n    },\n    updateCreasesGraph(state, graph: CreasesGraph) {\n      state.creasesGraph = graph;\n    },\n    updatePacking(state, packing: Packing) {\n      state.packing = packing;\n    },\n    updateGlobalError(state, msg: string) {\n      state.globalError = msg;\n    },\n    clearGlobalError(state) {\n      state.globalError = undefined;\n    },\n    unsync(state) {\n      state.packingCreasesSynced = false;\n    },\n    sync(state) {\n      state.packingCreasesSynced = true;\n    }\n  }\n};\n\nconst store = new Vuex.Store<RootState>(storeTemplate);\n\nnew Vue({\n  render: h => h(App),\n  store: store\n}).$mount(\"#app\");\n"],"sourceRoot":""}